/****************************************************************************\
*
* This file is part of the "Luna KMU" tool.
*
* The "KMU" tool is provided under the MIT license (see the
* following Web site for further details: https://mit-license.org/ ).
*
* Author: Sebastien Chapellier
*
* Copyright Â© 2023-2024 Thales Group
*
\****************************************************************************/

#define _P11_UTIL_C_

#ifdef OS_WIN32
#include <windows.h>
#else
#include <dlfcn.h>
#endif
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "p11.h"
#include "p11util.h"

typedef struct P11_ECCCruve
{
   const CK_CHAR_PTR sCurveName;
   const CK_CHAR_PTR sCurveOID;
}P11_ECC_CURVE;

typedef struct P11_Mech
{
   const CK_CHAR_PTR sMechName;
   const CK_MECHANISM_TYPE ckMechType;
}P11_MECH;

typedef struct P11_KeyType
{
   const CK_CHAR_PTR sKeyTypeName;
   const CK_KEY_TYPE cktype;
   const CK_OBJECT_CLASS ckClass;
}P11_KEY_TYPE_KG;

const CK_CHAR STRING_TRUE[] = "true";
const CK_CHAR STRING_FALSE[] = "false";

const CK_CHAR CLASS_DATA[] = "DataObject";
const CK_CHAR CLASS_CERTIFICATE[] = "Certificate";
const CK_CHAR CLASS_PUBLICKEY[] = "Public Key";
const CK_CHAR CLASS_PRIVATEKEY[] = "Private Key";
const CK_CHAR CLASS_SECRETKEY[] = "Secret Key";
const CK_CHAR CLASS_UNKNOWN[] = "Unknown";

/******************** param -keytype *********************/
typedef struct parser_KeyType
{
   const CK_CHAR_PTR       sKeyTypeName;
   const CK_KEY_TYPE       cktype;
   const CK_OBJECT_CLASS   ckClass;
   const CK_ULONG          uFlag;
}PARSER_KEY_TYPE;

const CK_CHAR KEY_TYPE_DES[] = "des";
const CK_CHAR KEY_TYPE_DES2[] = "des2";
const CK_CHAR KEY_TYPE_DES3[] = "des3";
const CK_CHAR KEY_TYPE_AES[] = "aes";
const CK_CHAR KEY_TYPE_RSA[] = "rsa";
const CK_CHAR KEY_TYPE_ECDSA[] = "ecdsa";
const CK_CHAR KEY_TYPE_EDDSA[] = "eddsa";
const CK_CHAR KEY_TYPE_SM2[] = "sm2";
const CK_CHAR KEY_TYPE_SM4[] = "sm4";
const CK_CHAR KEY_TYPE_HMAC[] = "hmac";
const CK_CHAR KEY_TYPE_MONTGOMERY[] = "montgomery";
const CK_CHAR KEY_TYPE_DH[] = "dh";
const CK_CHAR KEY_TYPE_DSA[] = "dsa";
const CK_CHAR KEY_TYPE_X942_DH[] = "dh-x9.42";
const CK_CHAR KEY_TYPE_GENERIC[] = "genericsecret";
const CK_CHAR KEY_TYPE_MD_DSA[] = "ml-dsa";

const CK_CHAR KEY_TYPE_KEA[] = "kea";
const CK_CHAR KEY_TYPE_RC2[] = "rc2";
const CK_CHAR KEY_TYPE_RC4[] = "rc4";
const CK_CHAR KEY_TYPE_RC5[] = "rc5";
const CK_CHAR KEY_TYPE_CAST[] = "cast";
const CK_CHAR KEY_TYPE_CAST3[] = "cast3";
const CK_CHAR KEY_TYPE_CAST5[] = "cast5";
const CK_CHAR KEY_TYPE_CAST128[] = "cast128";
const CK_CHAR KEY_TYPE_KCDSA[] = "kcdsa";
const CK_CHAR KEY_TYPE_KSEED[] = "korean seed";
const CK_CHAR KEY_TYPE_BIP32[] = "bip32";
const CK_CHAR KEY_TYPE_IDEA[] = "idea";

#define SIZE_KEYGEN_SUPPORTED_TYPE_TABLE      DIM(arg_keygen_supported_type)
const PARSER_KEY_TYPE arg_keygen_supported_type[] = {
   {(CK_CHAR_PTR)&KEY_TYPE_AES,           CKK_AES,                CKO_SECRET_KEY,   KEY_TYPE_GENKEY | KEY_TYPE_IMPORT_EXPORTKEY | KEY_TYPE_DERIVEKEY | KEY_TYPE_DISPLAY | KEY_TYPE_MZMK},
   {(CK_CHAR_PTR)&KEY_TYPE_SM4,           CKK_SM4,                CKO_SECRET_KEY,   KEY_TYPE_GENKEY | KEY_TYPE_IMPORT_EXPORTKEY | KEY_TYPE_DISPLAY},
   {(CK_CHAR_PTR)&KEY_TYPE_DES,           CKK_DES,                CKO_SECRET_KEY,   KEY_TYPE_GENKEY | KEY_TYPE_IMPORT_EXPORTKEY | KEY_TYPE_DERIVEKEY | KEY_TYPE_DISPLAY | KEY_TYPE_MZMK},
   {(CK_CHAR_PTR)&KEY_TYPE_DES2,          CKK_DES2,               CKO_SECRET_KEY,   KEY_TYPE_IMPORT_EXPORTKEY | KEY_TYPE_DISPLAY},
   {(CK_CHAR_PTR)&KEY_TYPE_DES3,          CKK_DES3,               CKO_SECRET_KEY,   KEY_TYPE_IMPORT_EXPORTKEY | KEY_TYPE_DISPLAY},
   {(CK_CHAR_PTR)&KEY_TYPE_GENERIC,       CKK_GENERIC_SECRET,     CKO_SECRET_KEY,   KEY_TYPE_GENKEY | KEY_TYPE_DERIVEKEY | KEY_TYPE_DISPLAY},
   {(CK_CHAR_PTR)&KEY_TYPE_HMAC,          CKK_GENERIC_SECRET,     CKO_SECRET_KEY,   KEY_TYPE_IMPORT_EXPORTKEY | KEY_TYPE_GENKEY | KEY_TYPE_DERIVEKEY | KEY_TYPE_DISPLAY},
   {(CK_CHAR_PTR)&KEY_TYPE_RSA,           CKK_RSA,                CKO_PRIVATE_KEY,  KEY_TYPE_GENKEY | KEY_TYPE_IMPORT_EXPORTKEY | KEY_TYPE_DISPLAY},
   {(CK_CHAR_PTR)&KEY_TYPE_DH,            CKK_DH,                 CKO_PRIVATE_KEY,  KEY_TYPE_GENKEY | KEY_TYPE_IMPORT_EXPORTKEY | KEY_TYPE_DISPLAY},
   {(CK_CHAR_PTR)&KEY_TYPE_X942_DH,       CKK_X9_42_DH,           CKO_PRIVATE_KEY,  KEY_TYPE_IMPORT_EXPORTKEY | KEY_TYPE_DISPLAY},
   {(CK_CHAR_PTR)&KEY_TYPE_DSA,           CKK_DSA,                CKO_PRIVATE_KEY,  KEY_TYPE_GENKEY | KEY_TYPE_IMPORT_EXPORTKEY | KEY_TYPE_DISPLAY},
   {(CK_CHAR_PTR)&KEY_TYPE_ECDSA,         CKK_ECDSA,              CKO_PRIVATE_KEY,  KEY_TYPE_GENKEY | KEY_TYPE_IMPORT_EXPORTKEY | KEY_TYPE_DISPLAY},
   {(CK_CHAR_PTR)&KEY_TYPE_EDDSA,         CKK_EC_EDWARDS,         CKO_PRIVATE_KEY,  KEY_TYPE_GENKEY | KEY_TYPE_IMPORT_EXPORTKEY | KEY_TYPE_DISPLAY},
   {(CK_CHAR_PTR)&KEY_TYPE_EDDSA,         CKK_EC_EDWARDS_OLD,     CKO_PRIVATE_KEY,  KEY_TYPE_DISPLAY},
   {(CK_CHAR_PTR)&KEY_TYPE_MONTGOMERY,    CKK_EC_MONTGOMERY,      CKO_PRIVATE_KEY,  KEY_TYPE_GENKEY | KEY_TYPE_IMPORT_EXPORTKEY | KEY_TYPE_DISPLAY},
   {(CK_CHAR_PTR)&KEY_TYPE_MONTGOMERY,    CKK_EC_MONTGOMERY_OLD,  CKO_PRIVATE_KEY,  KEY_TYPE_DISPLAY},
   {(CK_CHAR_PTR)&KEY_TYPE_SM2,           CKK_SM2,                CKO_PRIVATE_KEY,  KEY_TYPE_GENKEY | KEY_TYPE_IMPORT_EXPORTKEY | KEY_TYPE_DISPLAY},
   {(CK_CHAR_PTR)&KEY_TYPE_MD_DSA,        CKK_ML_DSA,             CKO_PRIVATE_KEY,  KEY_TYPE_GENKEY | KEY_TYPE_IMPORT_EXPORTKEY | KEY_TYPE_DISPLAY},
   {(CK_CHAR_PTR)&KEY_TYPE_KEA,           CKK_KEA,                CKO_PRIVATE_KEY,  KEY_TYPE_DISPLAY},
   {(CK_CHAR_PTR)&KEY_TYPE_RC2,           CKK_RC2,                CKO_SECRET_KEY,   KEY_TYPE_DISPLAY},
   {(CK_CHAR_PTR)&KEY_TYPE_RC4,           CKK_RC4,                CKO_SECRET_KEY,   KEY_TYPE_DISPLAY},
   {(CK_CHAR_PTR)&KEY_TYPE_RC5,           CKK_RC5,                CKO_SECRET_KEY,   KEY_TYPE_DISPLAY},
   {(CK_CHAR_PTR)&KEY_TYPE_CAST,          CKK_CAST,               CKO_SECRET_KEY,   KEY_TYPE_DISPLAY},
   {(CK_CHAR_PTR)&KEY_TYPE_CAST3,         CKK_CAST3,              CKO_SECRET_KEY,   KEY_TYPE_DISPLAY},
   {(CK_CHAR_PTR)&KEY_TYPE_CAST5,         CKK_CAST5,              CKO_SECRET_KEY,   KEY_TYPE_DISPLAY},
   {(CK_CHAR_PTR)&KEY_TYPE_CAST128,       CKK_CAST128,            CKO_SECRET_KEY,   KEY_TYPE_DISPLAY},
   {(CK_CHAR_PTR)&KEY_TYPE_IDEA,          CKK_IDEA,               CKO_SECRET_KEY,   KEY_TYPE_DISPLAY},
   {(CK_CHAR_PTR)&KEY_TYPE_KCDSA,         CKK_KCDSA,              CKO_PRIVATE_KEY,  KEY_TYPE_DISPLAY},
   {(CK_CHAR_PTR)&KEY_TYPE_KSEED,         CKK_SEED_OLD,           CKO_SECRET_KEY,   KEY_TYPE_DISPLAY},
   {(CK_CHAR_PTR)&KEY_TYPE_BIP32,         CKK_BIP32,              CKO_SECRET_KEY,   KEY_TYPE_DISPLAY},
};

/*
#define SIZE_KEY_TYPE_TABLE_DISPLAY      DIM(arg_key_type_display)
const PARSER_KEY_TYPE arg_key_type_display[] = {
   {(CK_CHAR_PTR)&KEY_TYPE_AES,           CKK_AES,                CKO_SECRET_KEY},
   {(CK_CHAR_PTR)&KEY_TYPE_SM4,           CKK_SM4,                CKO_SECRET_KEY},
   {(CK_CHAR_PTR)&KEY_TYPE_DES,           CKK_DES,                CKO_SECRET_KEY},
   {(CK_CHAR_PTR)&KEY_TYPE_DES2,          CKK_DES2,               CKO_SECRET_KEY},
   {(CK_CHAR_PTR)&KEY_TYPE_DES3,          CKK_DES3,               CKO_SECRET_KEY},
   {(CK_CHAR_PTR)&KEY_TYPE_GENERIC,       CKK_GENERIC_SECRET,     CKO_SECRET_KEY},
   {(CK_CHAR_PTR)&KEY_TYPE_RSA,           CKK_RSA,                CKO_PRIVATE_KEY},
   {(CK_CHAR_PTR)&KEY_TYPE_DH,            CKK_DH,                 CKO_PRIVATE_KEY},
   {(CK_CHAR_PTR)&KEY_TYPE_X942_DH,       CKK_X9_42_DH,           CKO_PRIVATE_KEY},
   {(CK_CHAR_PTR)&KEY_TYPE_ECDSA,         CKK_ECDSA,              CKO_PRIVATE_KEY},
   {(CK_CHAR_PTR)&KEY_TYPE_EDDSA,         CKK_EC_EDWARDS,         CKO_PRIVATE_KEY},
   {(CK_CHAR_PTR)&KEY_TYPE_EDDSA,         CKK_EC_EDWARDS_OLD,     CKO_PRIVATE_KEY},
   {(CK_CHAR_PTR)&KEY_TYPE_MONTGOMERY,    CKK_EC_MONTGOMERY,      CKO_PRIVATE_KEY},
   {(CK_CHAR_PTR)&KEY_TYPE_MONTGOMERY,    CKK_EC_MONTGOMERY_OLD,  CKO_PRIVATE_KEY},
   {(CK_CHAR_PTR)&KEY_TYPE_SM2,           CKK_SM2,                CKO_PRIVATE_KEY},
   {(CK_CHAR_PTR)&KEY_TYPE_DSA,           CKK_DSA,                CKO_PRIVATE_KEY},
   {(CK_CHAR_PTR)&KEY_TYPE_DH,            CKK_DH,                 CKO_PRIVATE_KEY},
};*/


/********************RSA MECHANSIM *********************/
const CK_CHAR MECH_GENRSA_PKCS[] = "pkcs";
const CK_CHAR MECH_GENRSA_PRIME[] = "prime";
const CK_CHAR MECH_GENRSA_AUX[] = "aux";

#define SIZE_RSA_MECH_TABLE     DIM(p11_rsa_mech)
const P11_MECH p11_rsa_mech[] = {
   {(CK_CHAR_PTR)&MECH_GENRSA_PKCS,    CKM_RSA_PKCS_KEY_PAIR_GEN},
   {(CK_CHAR_PTR)&MECH_GENRSA_PRIME,   CKM_RSA_FIPS_186_3_PRIME_KEY_PAIR_GEN},
   {(CK_CHAR_PTR)&MECH_GENRSA_AUX,     CKM_RSA_FIPS_186_3_AUX_PRIME_KEY_PAIR_GEN},
};

/********************DH MECHANSIM *********************/
const CK_CHAR MECH_GENDH_PKCS[] = "pkcs";
const CK_CHAR MECH_GENDH_PRIME[] = "x942";
#define SIZE_DH_MECH_TABLE     DIM(p11_dh_mech)
const P11_MECH p11_dh_mech[] = {
   {(CK_CHAR_PTR)&MECH_GENDH_PKCS,    CKM_DH_PKCS_KEY_PAIR_GEN},
   {(CK_CHAR_PTR)&MECH_GENDH_PRIME,   CKM_X9_42_DH_KEY_PAIR_GEN},
};

/********************Public key exponant *********************/
const CK_CHAR RSA_PUB_EXP_10001_NAME[] = "10001";
const CK_CHAR RSA_PUB_EXP_65537_NAME[] = "65537";
const CK_CHAR RSA_PUB_EXP_3_NAME[] = "3";
const CK_CHAR RSA_PUB_EXP_17_NAME[] = "17";

const CK_CHAR RSA_PUB_EXP_10001[] = { 0x01, 0x00, 0x01 };
const CK_CHAR RSA_PUB_EXP_3[] = { 0x03 };
const CK_CHAR RSA_PUB_EXP_17[] = { 0x17 };

#define SIZE_RSA_PUBEXP_TABLE     DIM(rsa_public_exp)
const P11_RSA_EXP rsa_public_exp[] = {
   {(CK_CHAR_PTR)&RSA_PUB_EXP_10001_NAME,sizeof(RSA_PUB_EXP_10001),(CK_CHAR_PTR)&RSA_PUB_EXP_10001},
   {(CK_CHAR_PTR)&RSA_PUB_EXP_65537_NAME,sizeof(RSA_PUB_EXP_10001),(CK_CHAR_PTR)&RSA_PUB_EXP_10001},
   {(CK_CHAR_PTR)&RSA_PUB_EXP_3_NAME,sizeof(RSA_PUB_EXP_3),(CK_CHAR_PTR)&RSA_PUB_EXP_3},
   {(CK_CHAR_PTR)&RSA_PUB_EXP_17_NAME,sizeof(RSA_PUB_EXP_17),(CK_CHAR_PTR)&RSA_PUB_EXP_17},
};

/********************ECC curve OID *********************/
const CK_CHAR ECC_CURVE_PRIME192V1[]         = "prime192v1";
const CK_CHAR ECC_CURVE_PRIME192V2[]         = "prime192v2";
const CK_CHAR ECC_CURVE_PRIME192V3[]         = "prime192v3";
const CK_CHAR ECC_CURVE_PRIME239V1[]         = "prime239v1";
const CK_CHAR ECC_CURVE_PRIME239V2[]         = "prime239v2";
const CK_CHAR ECC_CURVE_PRIME239V3[]         = "prime239v3";
const CK_CHAR ECC_CURVE_PRIME256V1[]         = "prime256v1";

const CK_CHAR ECC_CURVE_SECP112R1[]          = "secp112r1";
const CK_CHAR ECC_CURVE_SECP112R2[]          = "secp112r2";
const CK_CHAR ECC_CURVE_SECP113R1[]          = "sect113r1";
const CK_CHAR ECC_CURVE_SECP113R2[]          = "sect113r2";
const CK_CHAR ECC_CURVE_SECP128R1[]          = "secp128r1";
const CK_CHAR ECC_CURVE_SECP128R2[]          = "secp128r2";
const CK_CHAR ECC_CURVE_SECP131R1[]          = "sect131r1";
const CK_CHAR ECC_CURVE_SECP131R2[]          = "sect131r2";
const CK_CHAR ECC_CURVE_SECP160R1[]          = "secp160r1";
const CK_CHAR ECC_CURVE_SECP160K1[]          = "secp160k1";
const CK_CHAR ECC_CURVE_SECP160R2[]          = "secp160r2";
const CK_CHAR ECC_CURVE_SECP163K1[]          = "sect163k1";
const CK_CHAR ECC_CURVE_SECP163R1[]          = "sect163r1";
const CK_CHAR ECC_CURVE_SECP163R2[]          = "sect163r2";
const CK_CHAR ECC_CURVE_SECP192K1[]          = "secp192k1";
const CK_CHAR ECC_CURVE_SECP193R1[]          = "sect193r1";
const CK_CHAR ECC_CURVE_SECP193R2[]          = "sect193r2";
const CK_CHAR ECC_CURVE_SECP224K1[]          = "secp224k1";
const CK_CHAR ECC_CURVE_SECP224R1[]          = "secp224r1";
const CK_CHAR ECC_CURVE_SECP233K1[]          = "sect233k1";
const CK_CHAR ECC_CURVE_SECP233R1[]          = "sect233r1";
const CK_CHAR ECC_CURVE_SECP239K1[]          = "sect239k1";
const CK_CHAR ECC_CURVE_SECP256R1[]          = "secp256r1";
const CK_CHAR ECC_CURVE_SECP256K1[]          = "secp256k1";
const CK_CHAR ECC_CURVE_SECP283K1[]          = "sect283k1";
const CK_CHAR ECC_CURVE_SECP283R1[]          = "sect283r1";
const CK_CHAR ECC_CURVE_SECP384R1[]          = "secp384r1";
const CK_CHAR ECC_CURVE_SECP409K1[]          = "sect409k1";
const CK_CHAR ECC_CURVE_SECP409R1[]          = "sect409r1";
const CK_CHAR ECC_CURVE_SECP521R1[]          = "secp521r1";
const CK_CHAR ECC_CURVE_SECP571K1[]          = "sect571k1";
const CK_CHAR ECC_CURVE_SECP571R1[]          = "sect571r1";

const CK_CHAR ECC_CURVE_BRAINPOOLP160R1[]    = "brainpoolP160r1";
const CK_CHAR ECC_CURVE_BRAINPOOLP160T1[]    = "brainpoolP160t1";
const CK_CHAR ECC_CURVE_BRAINPOOLP192R1[]    = "brainpoolP192r1";
const CK_CHAR ECC_CURVE_BRAINPOOLP192T1[]    = "brainpoolP192t1";
const CK_CHAR ECC_CURVE_BRAINPOOLP224R1[]    = "brainpoolP224r1";
const CK_CHAR ECC_CURVE_BRAINPOOLP224T1[]    = "brainpoolP224t1";
const CK_CHAR ECC_CURVE_BRAINPOOLP256R1[]    = "brainpoolP256r1";
const CK_CHAR ECC_CURVE_BRAINPOOLP256T1[]    = "brainpoolP256t1";
const CK_CHAR ECC_CURVE_BRAINPOOLP320R1[]    = "brainpoolP320r1";
const CK_CHAR ECC_CURVE_BRAINPOOLP320T1[]    = "brainpoolP320t1";
const CK_CHAR ECC_CURVE_BRAINPOOLP384R1[]    = "brainpoolP384r1";
const CK_CHAR ECC_CURVE_BRAINPOOLP384T1[]    = "brainpoolP384t1";
const CK_CHAR ECC_CURVE_BRAINPOOLP512R1[]    = "brainpoolP512r1";
const CK_CHAR ECC_CURVE_BRAINPOOLP512T1[]    = "brainpoolP512t1";

const CK_CHAR ECC_CURVE_C2PNB163V1[]         = "c2pnb163v1";
const CK_CHAR ECC_CURVE_C2PNB163V2[]         = "c2pnb163v2";
const CK_CHAR ECC_CURVE_C2PNB163V3[]         = "c2pnb163v3";
const CK_CHAR ECC_CURVE_C2PNB176W1[]         = "c2pnb176w1";
const CK_CHAR ECC_CURVE_C2PNB191V1[]         = "c2tnb191v1";
const CK_CHAR ECC_CURVE_C2PNB191V2[]         = "c2tnb191v2";
const CK_CHAR ECC_CURVE_C2PNB191V3[]         = "c2tnb191v3";
const CK_CHAR ECC_CURVE_C2PNB208W1[]         = "c2pnb208w1";
const CK_CHAR ECC_CURVE_C2PNB239V1[]         = "c2pnb239v1";
const CK_CHAR ECC_CURVE_C2PNB239V2[]         = "c2pnb239v2";
const CK_CHAR ECC_CURVE_C2PNB239V3[]         = "c2pnb239v3";
const CK_CHAR ECC_CURVE_C2PNB272W1[]         = "c2pnb272w1";
const CK_CHAR ECC_CURVE_C2PNB304W1[]         = "c2pnb304w1";
const CK_CHAR ECC_CURVE_C2PNB359V1[]         = "c2pnb359v1";
const CK_CHAR ECC_CURVE_C2PNB368W1[]         = "c2pnb368w1";
const CK_CHAR ECC_CURVE_C2PNB431R1[]         = "c2pnb431r1";

const CK_CHAR ECC_CURVE_ED25519[] = "ed25519";
const CK_CHAR ECC_CURVE_ED448[] = "ed448";
const CK_CHAR ECC_CURVE_X25519[] = "x25519";
const CK_CHAR ECC_CURVE_X448[] = "x448";
const CK_CHAR ECC_CURVE_SM2[] = "sm2";

// x9 42 curve
const CK_CHAR ECC_CURVE_PRIME192V1_OID[] = { 0x06, 0x08, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x03, 0x01, 0x01 }; 
const CK_CHAR ECC_CURVE_PRIME192V2_OID[] = { 0x06, 0x08, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x03, 0x01, 0x02 };
const CK_CHAR ECC_CURVE_PRIME192V3_OID[] = { 0x06, 0x08, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x03, 0x01, 0x03 };
const CK_CHAR ECC_CURVE_PRIME239V1_OID[] = { 0x06, 0x08, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x03, 0x01, 0x04 };
const CK_CHAR ECC_CURVE_PRIME239V2_OID[] = { 0x06, 0x08, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x03, 0x01, 0x05 };
const CK_CHAR ECC_CURVE_PRIME239V3_OID[] = { 0x06, 0x08, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x03, 0x01, 0x06 };
const CK_CHAR ECC_CURVE_PRIME256R1_OID[] = { 0x06, 0x08, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x03, 0x01, 0x07 }; // "\x06\x08\x2A\x86\x48\xCE\x3D\x03\x01\x07"

const CK_CHAR ECC_CURVE_SECP163K1_OID[] = { 0x06, 0x05, 0x2B, 0x81, 0x04, 0x00, 0x01 };
const CK_CHAR ECC_CURVE_SECP163R1_OID[] = { 0x06, 0x05, 0x2B, 0x81, 0x04, 0x00, 0x02 };
const CK_CHAR ECC_CURVE_SECP239K1_OID[] = { 0x06, 0x05, 0x2B, 0x81, 0x04, 0x00, 0x03 };
const CK_CHAR ECC_CURVE_SECP113R1_OID[] = { 0x06, 0x05, 0x2B, 0x81, 0x04, 0x00, 0x04 };
const CK_CHAR ECC_CURVE_SECP113R2_OID[] = { 0x06, 0x05, 0x2B, 0x81, 0x04, 0x00, 0x05 };
const CK_CHAR ECC_CURVE_SECP112R1_OID[] = { 0x06, 0x05, 0x2B, 0x81, 0x04, 0x00, 0x06 };
const CK_CHAR ECC_CURVE_SECP112R2_OID[] = { 0x06, 0x05, 0x2B, 0x81, 0x04, 0x00, 0x07 };
const CK_CHAR ECC_CURVE_SECP160R1_OID[] = { 0x06, 0x05, 0x2B, 0x81, 0x04, 0x00, 0x08 };
const CK_CHAR ECC_CURVE_SECP160K1_OID[] = { 0x06, 0x05, 0x2B, 0x81, 0x04, 0x00, 0x09 };
const CK_CHAR ECC_CURVE_SECP256K1_OID[] = { 0x06, 0x05, 0x2B, 0x81, 0x04, 0x00, 0x0A };
const CK_CHAR ECC_CURVE_SECP163R2_OID[] = { 0x06, 0x05, 0x2B, 0x81, 0x04, 0x00, 0x0F };
const CK_CHAR ECC_CURVE_SECP283K1_OID[] = { 0x06, 0x05, 0x2B, 0x81, 0x04, 0x00, 0x10 };
const CK_CHAR ECC_CURVE_SECP283R1_OID[] = { 0x06, 0x05, 0x2B, 0x81, 0x04, 0x00, 0x11 };
const CK_CHAR ECC_CURVE_SECP131R1_OID[] = { 0x06, 0x05, 0x2B, 0x81, 0x04, 0x00, 0x16 };
const CK_CHAR ECC_CURVE_SECP131R2_OID[] = { 0x06, 0x05, 0x2B, 0x81, 0x04, 0x00, 0x17 };
const CK_CHAR ECC_CURVE_SECP193R1_OID[] = { 0x06, 0x05, 0x2B, 0x81, 0x04, 0x00, 0x18 };
const CK_CHAR ECC_CURVE_SECP193R2_OID[] = { 0x06, 0x05, 0x2B, 0x81, 0x04, 0x00, 0x19 };
const CK_CHAR ECC_CURVE_SECP233K1_OID[] = { 0x06, 0x05, 0x2B, 0x81, 0x04, 0x00, 0x1A };
const CK_CHAR ECC_CURVE_SECP233R1_OID[] = { 0x06, 0x05, 0x2B, 0x81, 0x04, 0x00, 0x1B };
const CK_CHAR ECC_CURVE_SECP128R1_OID[] = { 0x06, 0x05, 0x2B, 0x81, 0x04, 0x00, 0x1C };
const CK_CHAR ECC_CURVE_SECP128R2_OID[] = { 0x06, 0x05, 0x2B, 0x81, 0x04, 0x00, 0x1D };
const CK_CHAR ECC_CURVE_SECP160R2_OID[] = { 0x06, 0x05, 0x2B, 0x81, 0x04, 0x00, 0x1E };
const CK_CHAR ECC_CURVE_SECP192K1_OID[] = { 0x06, 0x05, 0x2B, 0x81, 0x04, 0x00, 0x1F };
const CK_CHAR ECC_CURVE_SECP224K1_OID[] = { 0x06, 0x05, 0x2B, 0x81, 0x04, 0x00, 0x20 };
const CK_CHAR ECC_CURVE_SECP224R1_OID[] = { 0x06, 0x05, 0x2B, 0x81, 0x04, 0x00, 0x21 };
const CK_CHAR ECC_CURVE_SECP384R1_OID[] =  { 0x06, 0x05, 0x2B, 0x81, 0x04, 0x00, 0x22 };
const CK_CHAR ECC_CURVE_SECP521R1_OID[] =  { 0x06, 0x05, 0x2B, 0x81, 0x04, 0x00, 0x23 };
const CK_CHAR ECC_CURVE_SECP409K1_OID[] = { 0x06, 0x05, 0x2B, 0x81, 0x04, 0x00, 0x24 };
const CK_CHAR ECC_CURVE_SECP409R1_OID[] = { 0x06, 0x05, 0x2B, 0x81, 0x04, 0x00, 0x25 };
const CK_CHAR ECC_CURVE_SECP571K1_OID[] = { 0x06, 0x05, 0x2B, 0x81, 0x04, 0x00, 0x26 };
const CK_CHAR ECC_CURVE_SECP571R1_OID[] = { 0x06, 0x05, 0x2B, 0x81, 0x04, 0x00, 0x27 };

const CK_CHAR ECC_CURVE_C2PNB163V1_OID[] = { 0x06, 0x08, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x03, 0x00, 0x01 };
const CK_CHAR ECC_CURVE_C2PNB163V2_OID[] = { 0x06, 0x08, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x03, 0x00, 0x02 };
const CK_CHAR ECC_CURVE_C2PNB163V3_OID[] = { 0x06, 0x08, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x03, 0x00, 0x03 };
const CK_CHAR ECC_CURVE_C2PNB176W1_OID[] = { 0x06, 0x08, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x03, 0x00, 0x04 };
const CK_CHAR ECC_CURVE_C2PNB191V1_OID[] = { 0x06, 0x08, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x03, 0x00, 0x05 };
const CK_CHAR ECC_CURVE_C2PNB191V2_OID[] = { 0x06, 0x08, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x03, 0x00, 0x06 };
const CK_CHAR ECC_CURVE_C2PNB191V3_OID[] = { 0x06, 0x08, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x03, 0x00, 0x07 };
const CK_CHAR ECC_CURVE_C2PNB208W1_OID[] = { 0x06, 0x08, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x03, 0x00, 0x0A };
const CK_CHAR ECC_CURVE_C2PNB239V1_OID[] = { 0x06, 0x08, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x03, 0x00, 0x0B };
const CK_CHAR ECC_CURVE_C2PNB239V2_OID[] = { 0x06, 0x08, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x03, 0x00, 0x0C };
const CK_CHAR ECC_CURVE_C2PNB239V3_OID[] = { 0x06, 0x08, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x03, 0x00, 0x0D };
const CK_CHAR ECC_CURVE_C2PNB272W1_OID[] = { 0x06, 0x08, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x03, 0x00, 0x10 };
const CK_CHAR ECC_CURVE_C2PNB304W1_OID[] = { 0x06, 0x08, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x03, 0x00, 0x11 };
const CK_CHAR ECC_CURVE_C2PNB359V1_OID[] = { 0x06, 0x08, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x03, 0x00, 0x12 };
const CK_CHAR ECC_CURVE_C2PNB368W1_OID[] = { 0x06, 0x08, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x03, 0x00, 0x13 };
const CK_CHAR ECC_CURVE_C2PNB431R1_OID[] = { 0x06, 0x08, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x03, 0x00, 0x14 };

// brainpool curve
const CK_CHAR ECC_CURVE_BRAINPOOLP160R1_OID[] = { 0x06, 0x09, 0x2B, 0x24, 0x03, 0x03, 0x02, 0x08, 0x01, 0x01, 0x01 };
const CK_CHAR ECC_CURVE_BRAINPOOLP160T1_OID[] = { 0x06, 0x09, 0x2B, 0x24, 0x03, 0x03, 0x02, 0x08, 0x01, 0x01, 0x02 };
const CK_CHAR ECC_CURVE_BRAINPOOLP192R1_OID[] = { 0x06, 0x09, 0x2B, 0x24, 0x03, 0x03, 0x02, 0x08, 0x01, 0x01, 0x03 };
const CK_CHAR ECC_CURVE_BRAINPOOLP192T1_OID[] = { 0x06, 0x09, 0x2B, 0x24, 0x03, 0x03, 0x02, 0x08, 0x01, 0x01, 0x04 };
const CK_CHAR ECC_CURVE_BRAINPOOLP224R1_OID[] = { 0x06, 0x09, 0x2B, 0x24, 0x03, 0x03, 0x02, 0x08, 0x01, 0x01, 0x05 };
const CK_CHAR ECC_CURVE_BRAINPOOLP224T1_OID[] = { 0x06, 0x09, 0x2B, 0x24, 0x03, 0x03, 0x02, 0x08, 0x01, 0x01, 0x05 };
const CK_CHAR ECC_CURVE_BRAINPOOLP256R1_OID[] = { 0x06, 0x09, 0x2B, 0x24, 0x03, 0x03, 0x02, 0x08, 0x01, 0x01, 0x07 };
const CK_CHAR ECC_CURVE_BRAINPOOLP256T1_OID[] = { 0x06, 0x09, 0x2B, 0x24, 0x03, 0x03, 0x02, 0x08, 0x01, 0x01, 0x08 };
const CK_CHAR ECC_CURVE_BRAINPOOLP320R1_OID[] = { 0x06, 0x09, 0x2B, 0x24, 0x03, 0x03, 0x02, 0x08, 0x01, 0x01, 0x09 };
const CK_CHAR ECC_CURVE_BRAINPOOLP320T1_OID[] = { 0x06, 0x09, 0x2B, 0x24, 0x03, 0x03, 0x02, 0x08, 0x01, 0x01, 0x0A };
const CK_CHAR ECC_CURVE_BRAINPOOLP384R1_OID[] = { 0x06, 0x09, 0x2B, 0x24, 0x03, 0x03, 0x02, 0x08, 0x01, 0x01, 0x0B };
const CK_CHAR ECC_CURVE_BRAINPOOLP384T1_OID[] = { 0x06, 0x09, 0x2B, 0x24, 0x03, 0x03, 0x02, 0x08, 0x01, 0x01, 0x0C };
const CK_CHAR ECC_CURVE_BRAINPOOLP512R1_OID[] = { 0x06, 0x09, 0x2B, 0x24, 0x03, 0x03, 0x02, 0x08, 0x01, 0x01, 0x0D };
const CK_CHAR ECC_CURVE_BRAINPOOLP512T1_OID[] = { 0x06, 0x09, 0x2B, 0x24, 0x03, 0x03, 0x02, 0x08, 0x01, 0x01, 0x0E };

// EDDSA OID for Luna HSM
const CK_CHAR ECC_CURVE_ED25519_OID[] =         { 0x06, 0x09, 0x2B, 0x06, 0x01, 0x04, 0x01, 0xDA, 0x47, 0x0F, 0x01 };
const CK_CHAR ECC_CURVE_ED448_OID[] =           { 0x06, 0x09, 0x2B, 0x06, 0x01, 0x04, 0x01, 0xDA, 0x47, 0x0F, 0x02 };
const CK_CHAR ECC_CURVE_X25519_OID[] =          { 0x06, 0x0A, 0x2B, 0x06, 0x01, 0x04, 0x01, 0x97, 0x55, 0x01, 0x05, 0x01 };



// from standard https://datatracker.ietf.org/doc/html/rfc8410#page-9
const CK_CHAR OID_EDDSA_X25519_CURVE[]    = { 0x06, 0x03, 0x2B, 0x65, 0x6E };
const CK_CHAR OID_EDDSA_X448_CURVE[]      = { 0x06, 0x03, 0x2B, 0x65, 0x6F };
const CK_CHAR OID_EDDSA_ED25519_CURVE[]   = { 0x06, 0x03, 0x2B, 0x65, 0x70 };
const CK_CHAR OID_EDDSA_ED448_CURVE[]     = { 0x06, 0x03, 0x2B, 0x65, 0x71 };


//SM2 OID
const CK_CHAR ECC_CURVE_SM2_OID[] =             { 0x06, 0x08, 0x2A, 0x81, 0x1C, 0xCF, 0x55, 0x01, 0x82, 0x2D }; //06082A811CCF5501822D;


#define SIZE_ECC_CURVE_TABLE     DIM(ecc_curve_oid)
const P11_ECC_OID ecc_curve_oid[] = {
   // ECDSA
   {CKK_ECDSA,       (CK_CHAR_PTR)&ECC_CURVE_PRIME192V1,       sizeof(ECC_CURVE_PRIME192V1_OID),      (CK_CHAR_PTR)&ECC_CURVE_PRIME192V1_OID},
   {CKK_ECDSA,       (CK_CHAR_PTR)&ECC_CURVE_PRIME192V2,       sizeof(ECC_CURVE_PRIME192V2_OID),      (CK_CHAR_PTR)&ECC_CURVE_PRIME192V2_OID},
   {CKK_ECDSA,       (CK_CHAR_PTR)&ECC_CURVE_PRIME192V2,       sizeof(ECC_CURVE_PRIME192V3_OID),      (CK_CHAR_PTR)&ECC_CURVE_PRIME192V3_OID},
   {CKK_ECDSA,       (CK_CHAR_PTR)&ECC_CURVE_PRIME239V1,       sizeof(ECC_CURVE_PRIME239V1_OID),      (CK_CHAR_PTR)&ECC_CURVE_PRIME239V1_OID},
   {CKK_ECDSA,       (CK_CHAR_PTR)&ECC_CURVE_PRIME239V2,       sizeof(ECC_CURVE_PRIME239V2_OID),      (CK_CHAR_PTR)&ECC_CURVE_PRIME239V2_OID},
   {CKK_ECDSA,       (CK_CHAR_PTR)&ECC_CURVE_PRIME239V3,       sizeof(ECC_CURVE_PRIME239V3_OID),      (CK_CHAR_PTR)&ECC_CURVE_PRIME239V3_OID},
   {CKK_ECDSA,       (CK_CHAR_PTR)&ECC_CURVE_PRIME256V1,       sizeof(ECC_CURVE_PRIME256R1_OID),      (CK_CHAR_PTR)&ECC_CURVE_PRIME256R1_OID},
   {CKK_ECDSA,       (CK_CHAR_PTR)&ECC_CURVE_SECP112R1,        sizeof(ECC_CURVE_SECP112R1_OID),       (CK_CHAR_PTR)&ECC_CURVE_SECP112R1_OID},
   {CKK_ECDSA,       (CK_CHAR_PTR)&ECC_CURVE_SECP112R2,        sizeof(ECC_CURVE_SECP112R2_OID),       (CK_CHAR_PTR)&ECC_CURVE_SECP112R2_OID},
   {CKK_ECDSA,       (CK_CHAR_PTR)&ECC_CURVE_SECP113R1,        sizeof(ECC_CURVE_SECP113R1_OID),       (CK_CHAR_PTR)&ECC_CURVE_SECP113R1_OID},
   {CKK_ECDSA,       (CK_CHAR_PTR)&ECC_CURVE_SECP113R2,        sizeof(ECC_CURVE_SECP113R2_OID),       (CK_CHAR_PTR)&ECC_CURVE_SECP113R2_OID},
   {CKK_ECDSA,       (CK_CHAR_PTR)&ECC_CURVE_SECP128R1,        sizeof(ECC_CURVE_SECP128R1_OID),       (CK_CHAR_PTR)&ECC_CURVE_SECP128R1_OID},
   {CKK_ECDSA,       (CK_CHAR_PTR)&ECC_CURVE_SECP128R2,        sizeof(ECC_CURVE_SECP128R2_OID),       (CK_CHAR_PTR)&ECC_CURVE_SECP128R2_OID},
   {CKK_ECDSA,       (CK_CHAR_PTR)&ECC_CURVE_SECP131R1,        sizeof(ECC_CURVE_SECP131R1_OID),       (CK_CHAR_PTR)&ECC_CURVE_SECP131R1_OID},
   {CKK_ECDSA,       (CK_CHAR_PTR)&ECC_CURVE_SECP131R2,        sizeof(ECC_CURVE_SECP131R2_OID),       (CK_CHAR_PTR)&ECC_CURVE_SECP131R2_OID},  
   {CKK_ECDSA,       (CK_CHAR_PTR)&ECC_CURVE_SECP160R1,        sizeof(ECC_CURVE_SECP160R1_OID),       (CK_CHAR_PTR)&ECC_CURVE_SECP160R1_OID},
   {CKK_ECDSA,       (CK_CHAR_PTR)&ECC_CURVE_SECP160K1,        sizeof(ECC_CURVE_SECP160K1_OID),       (CK_CHAR_PTR)&ECC_CURVE_SECP160K1_OID},
   {CKK_ECDSA,       (CK_CHAR_PTR)&ECC_CURVE_SECP160R2,        sizeof(ECC_CURVE_SECP160R2_OID),       (CK_CHAR_PTR)&ECC_CURVE_SECP160R2_OID},
   {CKK_ECDSA,       (CK_CHAR_PTR)&ECC_CURVE_SECP163K1,        sizeof(ECC_CURVE_SECP163K1_OID),       (CK_CHAR_PTR)&ECC_CURVE_SECP163K1_OID},
   {CKK_ECDSA,       (CK_CHAR_PTR)&ECC_CURVE_SECP163R1,        sizeof(ECC_CURVE_SECP163R1_OID),       (CK_CHAR_PTR)&ECC_CURVE_SECP163R1_OID},
   {CKK_ECDSA,       (CK_CHAR_PTR)&ECC_CURVE_SECP163R2,        sizeof(ECC_CURVE_SECP163R2_OID),       (CK_CHAR_PTR)&ECC_CURVE_SECP163R2_OID},  
   {CKK_ECDSA,       (CK_CHAR_PTR)&ECC_CURVE_SECP192K1,        sizeof(ECC_CURVE_SECP192K1_OID),       (CK_CHAR_PTR)&ECC_CURVE_SECP192K1_OID},
   {CKK_ECDSA,       (CK_CHAR_PTR)&ECC_CURVE_SECP193R1,        sizeof(ECC_CURVE_SECP193R1_OID),       (CK_CHAR_PTR)&ECC_CURVE_SECP193R1_OID},
   {CKK_ECDSA,       (CK_CHAR_PTR)&ECC_CURVE_SECP193R2,        sizeof(ECC_CURVE_SECP193R2_OID),       (CK_CHAR_PTR)&ECC_CURVE_SECP193R2_OID},  
   {CKK_ECDSA,       (CK_CHAR_PTR)&ECC_CURVE_SECP224K1,        sizeof(ECC_CURVE_SECP224K1_OID),       (CK_CHAR_PTR)&ECC_CURVE_SECP224K1_OID},
   {CKK_ECDSA,       (CK_CHAR_PTR)&ECC_CURVE_SECP224R1,        sizeof(ECC_CURVE_SECP224R1_OID),       (CK_CHAR_PTR)&ECC_CURVE_SECP224R1_OID},
   {CKK_ECDSA,       (CK_CHAR_PTR)&ECC_CURVE_SECP233K1,        sizeof(ECC_CURVE_SECP233K1_OID),       (CK_CHAR_PTR)&ECC_CURVE_SECP233K1_OID},
   {CKK_ECDSA,       (CK_CHAR_PTR)&ECC_CURVE_SECP233R1,        sizeof(ECC_CURVE_SECP233R1_OID),       (CK_CHAR_PTR)&ECC_CURVE_SECP233R1_OID},
   {CKK_ECDSA,       (CK_CHAR_PTR)&ECC_CURVE_SECP239K1,        sizeof(ECC_CURVE_SECP239K1_OID),       (CK_CHAR_PTR)&ECC_CURVE_SECP239K1_OID}, 
   {CKK_ECDSA,       (CK_CHAR_PTR)&ECC_CURVE_SECP283K1,        sizeof(ECC_CURVE_SECP283K1_OID),       (CK_CHAR_PTR)&ECC_CURVE_SECP283K1_OID},
   {CKK_ECDSA,       (CK_CHAR_PTR)&ECC_CURVE_SECP283R1,        sizeof(ECC_CURVE_SECP283R1_OID),       (CK_CHAR_PTR)&ECC_CURVE_SECP283R1_OID},
   {CKK_ECDSA,       (CK_CHAR_PTR)&ECC_CURVE_SECP256R1,        sizeof(ECC_CURVE_PRIME256R1_OID),      (CK_CHAR_PTR)&ECC_CURVE_PRIME256R1_OID},
   {CKK_ECDSA,       (CK_CHAR_PTR)&ECC_CURVE_SECP256K1,        sizeof(ECC_CURVE_SECP256K1_OID),       (CK_CHAR_PTR)&ECC_CURVE_SECP256K1_OID},
   {CKK_ECDSA,       (CK_CHAR_PTR)&ECC_CURVE_SECP384R1,        sizeof(ECC_CURVE_SECP384R1_OID),       (CK_CHAR_PTR)&ECC_CURVE_SECP384R1_OID},
   {CKK_ECDSA,       (CK_CHAR_PTR)&ECC_CURVE_SECP409K1,        sizeof(ECC_CURVE_SECP409K1_OID),       (CK_CHAR_PTR)&ECC_CURVE_SECP409K1_OID},
   {CKK_ECDSA,       (CK_CHAR_PTR)&ECC_CURVE_SECP409R1,        sizeof(ECC_CURVE_SECP409R1_OID),       (CK_CHAR_PTR)&ECC_CURVE_SECP409R1_OID},
   {CKK_ECDSA,       (CK_CHAR_PTR)&ECC_CURVE_SECP521R1,        sizeof(ECC_CURVE_SECP521R1_OID),       (CK_CHAR_PTR)&ECC_CURVE_SECP521R1_OID},
   {CKK_ECDSA,       (CK_CHAR_PTR)&ECC_CURVE_SECP571K1,        sizeof(ECC_CURVE_SECP571K1_OID),       (CK_CHAR_PTR)&ECC_CURVE_SECP571K1_OID},
   {CKK_ECDSA,       (CK_CHAR_PTR)&ECC_CURVE_SECP571R1,        sizeof(ECC_CURVE_SECP571R1_OID),       (CK_CHAR_PTR)&ECC_CURVE_SECP571R1_OID},
   {CKK_ECDSA,       (CK_CHAR_PTR)&ECC_CURVE_BRAINPOOLP160R1,  sizeof(ECC_CURVE_BRAINPOOLP160R1_OID), (CK_CHAR_PTR)&ECC_CURVE_BRAINPOOLP160R1_OID},
   {CKK_ECDSA,       (CK_CHAR_PTR)&ECC_CURVE_BRAINPOOLP160T1,  sizeof(ECC_CURVE_BRAINPOOLP160T1_OID), (CK_CHAR_PTR)&ECC_CURVE_BRAINPOOLP160T1_OID},
   {CKK_ECDSA,       (CK_CHAR_PTR)&ECC_CURVE_BRAINPOOLP192R1,  sizeof(ECC_CURVE_BRAINPOOLP192R1_OID), (CK_CHAR_PTR)&ECC_CURVE_BRAINPOOLP192R1_OID},
   {CKK_ECDSA,       (CK_CHAR_PTR)&ECC_CURVE_BRAINPOOLP192T1,  sizeof(ECC_CURVE_BRAINPOOLP192T1_OID), (CK_CHAR_PTR)&ECC_CURVE_BRAINPOOLP192T1_OID},
   {CKK_ECDSA,       (CK_CHAR_PTR)&ECC_CURVE_BRAINPOOLP224R1,  sizeof(ECC_CURVE_BRAINPOOLP224R1_OID), (CK_CHAR_PTR)&ECC_CURVE_BRAINPOOLP224R1_OID},
   {CKK_ECDSA,       (CK_CHAR_PTR)&ECC_CURVE_BRAINPOOLP224T1,  sizeof(ECC_CURVE_BRAINPOOLP224T1_OID), (CK_CHAR_PTR)&ECC_CURVE_BRAINPOOLP224T1_OID},
   {CKK_ECDSA,       (CK_CHAR_PTR)&ECC_CURVE_BRAINPOOLP256R1,  sizeof(ECC_CURVE_BRAINPOOLP256R1_OID), (CK_CHAR_PTR)&ECC_CURVE_BRAINPOOLP256R1_OID},
   {CKK_ECDSA,       (CK_CHAR_PTR)&ECC_CURVE_BRAINPOOLP256T1,  sizeof(ECC_CURVE_BRAINPOOLP256T1_OID), (CK_CHAR_PTR)&ECC_CURVE_BRAINPOOLP256T1_OID},
   {CKK_ECDSA,       (CK_CHAR_PTR)&ECC_CURVE_BRAINPOOLP320R1,  sizeof(ECC_CURVE_BRAINPOOLP320R1_OID), (CK_CHAR_PTR)&ECC_CURVE_BRAINPOOLP320R1_OID},
   {CKK_ECDSA,       (CK_CHAR_PTR)&ECC_CURVE_BRAINPOOLP320T1,  sizeof(ECC_CURVE_BRAINPOOLP320T1_OID), (CK_CHAR_PTR)&ECC_CURVE_BRAINPOOLP320T1_OID},
   {CKK_ECDSA,       (CK_CHAR_PTR)&ECC_CURVE_BRAINPOOLP384R1,  sizeof(ECC_CURVE_BRAINPOOLP384R1_OID), (CK_CHAR_PTR)&ECC_CURVE_BRAINPOOLP384R1_OID},
   {CKK_ECDSA,       (CK_CHAR_PTR)&ECC_CURVE_BRAINPOOLP384T1,  sizeof(ECC_CURVE_BRAINPOOLP384T1_OID), (CK_CHAR_PTR)&ECC_CURVE_BRAINPOOLP384T1_OID},
   {CKK_ECDSA,       (CK_CHAR_PTR)&ECC_CURVE_BRAINPOOLP512R1,  sizeof(ECC_CURVE_BRAINPOOLP512R1_OID), (CK_CHAR_PTR)&ECC_CURVE_BRAINPOOLP512R1_OID},
   {CKK_ECDSA,       (CK_CHAR_PTR)&ECC_CURVE_BRAINPOOLP512T1,  sizeof(ECC_CURVE_BRAINPOOLP512T1_OID), (CK_CHAR_PTR)&ECC_CURVE_BRAINPOOLP512T1_OID},
   {CKK_ECDSA,       (CK_CHAR_PTR)&ECC_CURVE_C2PNB163V1,       sizeof(ECC_CURVE_C2PNB163V1_OID),      (CK_CHAR_PTR)&ECC_CURVE_C2PNB163V1_OID},
   {CKK_ECDSA,       (CK_CHAR_PTR)&ECC_CURVE_C2PNB163V1,       sizeof(ECC_CURVE_C2PNB163V1_OID),      (CK_CHAR_PTR)&ECC_CURVE_C2PNB163V1_OID},
   {CKK_ECDSA,       (CK_CHAR_PTR)&ECC_CURVE_C2PNB163V2,       sizeof(ECC_CURVE_C2PNB163V2_OID),      (CK_CHAR_PTR)&ECC_CURVE_C2PNB163V2_OID},
   {CKK_ECDSA,       (CK_CHAR_PTR)&ECC_CURVE_C2PNB163V3,       sizeof(ECC_CURVE_C2PNB163V3_OID),      (CK_CHAR_PTR)&ECC_CURVE_C2PNB163V3_OID},
   {CKK_ECDSA,       (CK_CHAR_PTR)&ECC_CURVE_C2PNB176W1,       sizeof(ECC_CURVE_C2PNB176W1_OID),      (CK_CHAR_PTR)&ECC_CURVE_C2PNB176W1_OID},
   {CKK_ECDSA,       (CK_CHAR_PTR)&ECC_CURVE_C2PNB191V1,       sizeof(ECC_CURVE_C2PNB191V1_OID),      (CK_CHAR_PTR)&ECC_CURVE_C2PNB191V1_OID},
   {CKK_ECDSA,       (CK_CHAR_PTR)&ECC_CURVE_C2PNB191V2,       sizeof(ECC_CURVE_C2PNB191V2_OID),      (CK_CHAR_PTR)&ECC_CURVE_C2PNB191V2_OID},
   {CKK_ECDSA,       (CK_CHAR_PTR)&ECC_CURVE_C2PNB191V3,       sizeof(ECC_CURVE_C2PNB191V3_OID),      (CK_CHAR_PTR)&ECC_CURVE_C2PNB191V3_OID},
   {CKK_ECDSA,       (CK_CHAR_PTR)&ECC_CURVE_C2PNB208W1,       sizeof(ECC_CURVE_C2PNB208W1_OID),      (CK_CHAR_PTR)&ECC_CURVE_C2PNB208W1_OID},
   {CKK_ECDSA,       (CK_CHAR_PTR)&ECC_CURVE_C2PNB239V1,       sizeof(ECC_CURVE_C2PNB239V1_OID),      (CK_CHAR_PTR)&ECC_CURVE_C2PNB239V1_OID},
   {CKK_ECDSA,       (CK_CHAR_PTR)&ECC_CURVE_C2PNB239V2,       sizeof(ECC_CURVE_C2PNB239V2_OID),      (CK_CHAR_PTR)&ECC_CURVE_C2PNB239V2_OID},
   {CKK_ECDSA,       (CK_CHAR_PTR)&ECC_CURVE_C2PNB239V3,       sizeof(ECC_CURVE_C2PNB239V3_OID),      (CK_CHAR_PTR)&ECC_CURVE_C2PNB239V3_OID},
   {CKK_ECDSA,       (CK_CHAR_PTR)&ECC_CURVE_C2PNB272W1,       sizeof(ECC_CURVE_C2PNB272W1_OID),      (CK_CHAR_PTR)&ECC_CURVE_C2PNB272W1_OID},
   {CKK_ECDSA,       (CK_CHAR_PTR)&ECC_CURVE_C2PNB304W1,       sizeof(ECC_CURVE_C2PNB304W1_OID),      (CK_CHAR_PTR)&ECC_CURVE_C2PNB304W1_OID},
   {CKK_ECDSA,       (CK_CHAR_PTR)&ECC_CURVE_C2PNB359V1,       sizeof(ECC_CURVE_C2PNB359V1_OID),      (CK_CHAR_PTR)&ECC_CURVE_C2PNB359V1_OID},
   {CKK_ECDSA,       (CK_CHAR_PTR)&ECC_CURVE_C2PNB368W1,       sizeof(ECC_CURVE_C2PNB368W1_OID),      (CK_CHAR_PTR)&ECC_CURVE_C2PNB368W1_OID},
   {CKK_ECDSA,       (CK_CHAR_PTR)&ECC_CURVE_C2PNB431R1,       sizeof(ECC_CURVE_C2PNB431R1_OID),      (CK_CHAR_PTR)&ECC_CURVE_C2PNB431R1_OID},
   
   // EDDSA 
   {CKK_EC_EDWARDS,  (CK_CHAR_PTR)&ECC_CURVE_ED25519,    sizeof(ECC_CURVE_ED25519_OID),   (CK_CHAR_PTR)&ECC_CURVE_ED25519_OID},
   {CKK_EC_EDWARDS,  (CK_CHAR_PTR)&ECC_CURVE_ED448,      sizeof(ECC_CURVE_ED448_OID),   (CK_CHAR_PTR)&ECC_CURVE_ED448_OID},
   // montgomary 
   {CKK_EC_MONTGOMERY,(CK_CHAR_PTR)&ECC_CURVE_X25519,   sizeof(ECC_CURVE_X25519_OID),   (CK_CHAR_PTR)&ECC_CURVE_X25519_OID},
   // SM2
   {CKK_SM2,         (CK_CHAR_PTR)&ECC_CURVE_SM2,        sizeof(ECC_CURVE_SM2_OID),       (CK_CHAR_PTR)&ECC_CURVE_SM2_OID},
};

#define SIZE_EDDSA_CONVERT_OID     DIM(eddsa_Convert_oid)
const P11_EDDSA_OID_CONVERT eddsa_Convert_oid[] =
{
   {sizeof(OID_EDDSA_ED25519_CURVE),   (CK_CHAR_PTR)&OID_EDDSA_ED25519_CURVE,    sizeof(ECC_CURVE_ED25519_OID),   (CK_CHAR_PTR)&ECC_CURVE_ED25519_OID},
   {sizeof(OID_EDDSA_ED448_CURVE),     (CK_CHAR_PTR)&OID_EDDSA_ED448_CURVE,      sizeof(ECC_CURVE_ED448_OID),     (CK_CHAR_PTR)&ECC_CURVE_ED448_OID},
   {sizeof(OID_EDDSA_X25519_CURVE),    (CK_CHAR_PTR)&OID_EDDSA_X25519_CURVE,     sizeof(ECC_CURVE_X25519_OID),    (CK_CHAR_PTR)&ECC_CURVE_X25519_OID},
};


/******************** param -keyclass *********************/
typedef struct Parser_keyclass
{
   const CK_CHAR_PTR sParamName;
   const CK_ATTRIBUTE_TYPE ckClass;
}PARSER_KEY_CLASS;

const CK_CHAR ARG_KEY_CLASS_PUBLIC[] = "public";
const CK_CHAR ARG_KEY_CLASS_PRIVATE[] = "private";
const CK_CHAR ARG_KEY_CLASS_SECRET[] = "secret";


#define SIZE_ARG_KEY_CLASS		   DIM(arg_keyclass)
PARSER_KEY_CLASS arg_keyclass[] = {
   {(CK_CHAR_PTR)&ARG_KEY_CLASS_PUBLIC, CKO_PUBLIC_KEY},
   {(CK_CHAR_PTR)&ARG_KEY_CLASS_PRIVATE, CKO_PRIVATE_KEY},
   {(CK_CHAR_PTR)&ARG_KEY_CLASS_SECRET, CKO_SECRET_KEY},
};


/********************Encryption argument *********************/

const CK_CHAR ARG_ALG_SHA1[]   = "sha1";
const CK_CHAR ARG_ALG_SHA224[] = "sha224";
const CK_CHAR ARG_ALG_SHA256[] = "sha256";
const CK_CHAR ARG_ALG_SHA384[] = "sha384";
const CK_CHAR ARG_ALG_SHA512[] = "sha512";
const CK_CHAR ARG_ALG_SHA3_224[] = "sha3-224";
const CK_CHAR ARG_ALG_SHA3_256[] = "sha3-256";
const CK_CHAR ARG_ALG_SHA3_284[] = "sha3-384";
const CK_CHAR ARG_ALG_SHA3_512[] = "sha3-512";

const CK_CHAR ARG_ALG_AES_ECB[] = "aes_ecb";
const CK_CHAR ARG_ALG_AES_CBC[] = "aes_cbc";
const CK_CHAR ARG_ALG_AES_CBC_PAD[] = "aes_cbc_pad";
const CK_CHAR ARG_ALG_AES_CBC_PAD_IPSEC[] = "aes_cbc_pad_ipsec";
const CK_CHAR ARG_ALG_AES_CFB8[] = "aes_cfb8";
const CK_CHAR ARG_ALG_AES_CFB128[] = "aes_cfb128";
const CK_CHAR ARG_ALG_AES_OFB[] = "aes_ofb";
const CK_CHAR ARG_ALG_AES_GCM[] = "aes_gcm";
const CK_CHAR ARG_ALG_AES_KW[] = "aes_kw";
const CK_CHAR ARG_ALG_AES_KWP[] = "aes_kwp";
const CK_CHAR ARG_ALG_RSA_OAEP[]        = "rsa_oaep";
const CK_CHAR ARG_ALG_RSA_SHA256_OAEP[] = "rsa_oaep_sha256";
const CK_CHAR ARG_ALG_RSA_SHA384_OAEP[] = "rsa_oaep_sha384";
const CK_CHAR ARG_ALG_RSA_SHA512_OAEP[] = "rsa_oaep_sha512";
const CK_CHAR ARG_ALG_RSA_AES128_KEY_WRAP[] = "rsa_aes128";
const CK_CHAR ARG_ALG_RSA_AES192_KEY_WRAP[] = "rsa_aes192";
const CK_CHAR ARG_ALG_RSA_AES256_KEY_WRAP[] = "rsa_aes256";
const CK_CHAR ARG_ALG_RSA_PBFKD2_AES_128_CBC[] = "pbfkd2_aes128_cbc";
const CK_CHAR ARG_ALG_RSA_PBFKD2_AES_192_CBC[] = "pbfkd2_aes192_cbc";
const CK_CHAR ARG_ALG_RSA_PBFKD2_AES_256_CBC[] = "pbfkd2_aes256_cbc";

const CK_CHAR default_DES_IV[DES_IV_LENGTH] = { '1', '2', '3', '4', '5', '6', '7', '8'};
const CK_CHAR default_AES_IV[AES_IV_LENGTH] = { '1', '2', '3', '4', '5', '6', '7', '8', '1', '2', '3', '4', '5', '6', '7', '8' };
const CK_CHAR default_AES_GCM_IV[AES_IV_LENGTH] = { 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 };


#define SIZE_ENCRYPTION_ALGO_TABLE     DIM(encryption_algo)
const P11_ENCRYPTION_MECH encryption_algo[] = {
   {KEY_TYPE_ENCRYPT | KEY_TYPE_IMPORT_EXPORTKEY,  (CK_CHAR_PTR)&ARG_ALG_AES_ECB,                  CKM_AES_ECB,            .aes_param.iv = NULL},
   {KEY_TYPE_ENCRYPT | KEY_TYPE_IMPORT_EXPORTKEY,  (CK_CHAR_PTR)&ARG_ALG_AES_CBC,                  CKM_AES_CBC,            .aes_param.iv = (CK_CHAR_PTR)default_AES_IV},
   {KEY_TYPE_ENCRYPT | KEY_TYPE_IMPORT_EXPORTKEY,  (CK_CHAR_PTR)&ARG_ALG_AES_CBC_PAD,              CKM_AES_CBC_PAD,        .aes_param.iv = (CK_CHAR_PTR)default_AES_IV},
   {KEY_TYPE_ENCRYPT | KEY_TYPE_IMPORT_EXPORTKEY,  (CK_CHAR_PTR)&ARG_ALG_AES_CBC_PAD_IPSEC,        CKM_AES_CBC_PAD_IPSEC,  .aes_param.iv = (CK_CHAR_PTR)default_AES_IV},
   {KEY_TYPE_ENCRYPT,                              (CK_CHAR_PTR)&ARG_ALG_AES_CFB8,                 CKM_AES_CFB8,           .aes_param.iv = (CK_CHAR_PTR)default_AES_IV},
   {KEY_TYPE_ENCRYPT,                              (CK_CHAR_PTR)&ARG_ALG_AES_CFB128,               CKM_AES_CFB128,         .aes_param.iv = (CK_CHAR_PTR)default_AES_IV},
   {KEY_TYPE_ENCRYPT,                              (CK_CHAR_PTR)&ARG_ALG_AES_OFB,                  CKM_AES_OFB,            .aes_param.iv = (CK_CHAR_PTR)default_AES_IV},
   {KEY_TYPE_ENCRYPT | KEY_TYPE_IMPORT_EXPORTKEY,  (CK_CHAR_PTR)&ARG_ALG_AES_KW,                   CKM_AES_KW,             .aes_param.iv = NULL},
   {KEY_TYPE_ENCRYPT | KEY_TYPE_IMPORT_EXPORTKEY,  (CK_CHAR_PTR)&ARG_ALG_AES_KWP,                  CKM_AES_KWP,            .aes_param.iv = NULL},
   {KEY_TYPE_ENCRYPT | KEY_TYPE_IMPORT_EXPORTKEY,  (CK_CHAR_PTR)&ARG_ALG_AES_GCM,                  CKM_AES_GCM,            .aes_gcm_param.pIv = (CK_CHAR_PTR)default_AES_GCM_IV, .aes_gcm_param.ulIvLen = AES_IV_LENGTH, .aes_gcm_param.ulIvBits = AES_IV_LENGTH << 3, .aes_gcm_param.pAAD = NULL,.aes_gcm_param.ulAADLen = 0, .aes_gcm_param.ulTagBits = AES_GCM_AUTH_TAG_LENGTH_96 },
   {KEY_TYPE_ENCRYPT | KEY_TYPE_IMPORT_EXPORTKEY,  (CK_CHAR_PTR)&ARG_ALG_RSA_SHA256_OAEP,          CKM_RSA_PKCS_OAEP,      .rsa_oeap_param.hashAlg = CKM_SHA256, .rsa_oeap_param.mgf = CKG_MGF1_SHA256, .rsa_oeap_param.source = CKZ_DATA_SPECIFIED, .rsa_oeap_param.pSourceData = NULL,.rsa_oeap_param.ulSourceDataLen = 0 },
   {KEY_TYPE_ENCRYPT | KEY_TYPE_IMPORT_EXPORTKEY,  (CK_CHAR_PTR)&ARG_ALG_RSA_SHA384_OAEP,          CKM_RSA_PKCS_OAEP,      .rsa_oeap_param.hashAlg = CKM_SHA384, .rsa_oeap_param.mgf = CKG_MGF1_SHA384, .rsa_oeap_param.source = CKZ_DATA_SPECIFIED, .rsa_oeap_param.pSourceData = NULL,.rsa_oeap_param.ulSourceDataLen = 0 },
   {KEY_TYPE_ENCRYPT | KEY_TYPE_IMPORT_EXPORTKEY,  (CK_CHAR_PTR)&ARG_ALG_RSA_SHA512_OAEP,          CKM_RSA_PKCS_OAEP,      .rsa_oeap_param.hashAlg = CKM_SHA512, .rsa_oeap_param.mgf = CKG_MGF1_SHA512, .rsa_oeap_param.source = CKZ_DATA_SPECIFIED, .rsa_oeap_param.pSourceData = NULL,.rsa_oeap_param.ulSourceDataLen = 0 },
   {KEY_TYPE_ENCRYPT | KEY_TYPE_IMPORT_EXPORTKEY,  (CK_CHAR_PTR)&ARG_ALG_RSA_OAEP,                 CKM_RSA_PKCS_OAEP,      .rsa_oeap_param.hashAlg = 0,          .rsa_oeap_param.mgf = 0,               .rsa_oeap_param.source = 0,                  .rsa_oeap_param.pSourceData = NULL,.rsa_oeap_param.ulSourceDataLen = 0 },
   {KEY_TYPE_IMPORT_EXPORTKEY                   ,  (CK_CHAR_PTR)&ARG_ALG_RSA_PBFKD2_AES_128_CBC,   CKM_PKCS5_PBKD2,        .pbkdf2_enc_param.ckMechSymType = CKM_AES_CBC_PAD, .pbkdf2_enc_param.skeySize = AES_128_KEY_LENGTH , .pbkdf2_enc_param.skeyType = CKK_AES, .pbkdf2_enc_param.sClass = CKO_SECRET_KEY ,.pbkdf2_enc_param.pbfkd2_param.prf = CKP_PKCS5_PBKD2_HMAC_SHA1, .pbkdf2_enc_param.uIVLength = AES_IV_LENGTH },
   {KEY_TYPE_IMPORT_EXPORTKEY                   ,  (CK_CHAR_PTR)&ARG_ALG_RSA_PBFKD2_AES_192_CBC,   CKM_PKCS5_PBKD2,        .pbkdf2_enc_param.ckMechSymType = CKM_AES_CBC_PAD, .pbkdf2_enc_param.skeySize = AES_192_KEY_LENGTH , .pbkdf2_enc_param.skeyType = CKK_AES, .pbkdf2_enc_param.sClass = CKO_SECRET_KEY ,.pbkdf2_enc_param.pbfkd2_param.prf = CKP_PKCS5_PBKD2_HMAC_SHA1, .pbkdf2_enc_param.uIVLength = AES_IV_LENGTH },
   {KEY_TYPE_IMPORT_EXPORTKEY                   ,  (CK_CHAR_PTR)&ARG_ALG_RSA_PBFKD2_AES_256_CBC,   CKM_PKCS5_PBKD2,        .pbkdf2_enc_param.ckMechSymType = CKM_AES_CBC_PAD, .pbkdf2_enc_param.skeySize = AES_256_KEY_LENGTH , .pbkdf2_enc_param.skeyType = CKK_AES, .pbkdf2_enc_param.sClass = CKO_SECRET_KEY ,.pbkdf2_enc_param.pbfkd2_param.prf = CKP_PKCS5_PBKD2_HMAC_SHA1, .pbkdf2_enc_param.uIVLength = AES_IV_LENGTH }
};



//CKM_RSA_AES_KEY_WRAP

//CK_RSA_AES_KEY_WRAP_PARAMS

const CK_CHAR ARG_DERIVE_SHA1[] = "sha1";
const CK_CHAR ARG_DERIVE_SHA224[] = "sha224";
const CK_CHAR ARG_DERIVE_SHA256[] = "sha256";
const CK_CHAR ARG_DERIVE_SHA384[] = "sha384";
const CK_CHAR ARG_DERIVE_SHA512[] = "sha512";
const CK_CHAR ARG_DERIVE_SHA3_224[] = "sha3-224";
const CK_CHAR ARG_DERIVE_SHA3_256[] = "sha3-256";
const CK_CHAR ARG_DERIVE_SHA3_384[] = "sha3-384";
const CK_CHAR ARG_DERIVE_SHA3_512[] = "sha3-512";
const CK_CHAR ARG_DERIVE_KDF[] = "luna-kdf";
const CK_CHAR ARG_DERIVE_NIST_KDF[] = "luna-nist-kdf";

#define SIZE_DERIVATION_ALGO_TABLE     DIM(derivation_algo)
const P11_DERIVE_MECH derivation_algo[] = {
   {(CK_CHAR_PTR)&ARG_DERIVE_SHA1,              CKM_SHA1_KEY_DERIVATION    },
   {(CK_CHAR_PTR)&ARG_DERIVE_SHA224,            CKM_SHA224_KEY_DERIVATION  },
   {(CK_CHAR_PTR)&ARG_DERIVE_SHA256,            CKM_SHA256_KEY_DERIVATION  },
   {(CK_CHAR_PTR)&ARG_DERIVE_SHA384,            CKM_SHA384_KEY_DERIVATION, },
   {(CK_CHAR_PTR)&ARG_DERIVE_SHA512,            CKM_SHA512_KEY_DERIVATION, },
   {(CK_CHAR_PTR)&ARG_DERIVE_SHA3_224,          CKM_SHA3_224_KEY_DERIVE,   },
   {(CK_CHAR_PTR)&ARG_DERIVE_SHA3_256,          CKM_SHA3_256_KEY_DERIVE,   },
   {(CK_CHAR_PTR)&ARG_DERIVE_SHA3_384,          CKM_SHA3_384_KEY_DERIVE,   },
   {(CK_CHAR_PTR)&ARG_DERIVE_SHA3_512,          CKM_SHA3_512_KEY_DERIVE,   },
   {(CK_CHAR_PTR)&ARG_DERIVE_KDF,               CKM_PRF_KDF,               },
   {(CK_CHAR_PTR)&ARG_DERIVE_NIST_KDF,          CKM_NIST_PRF_KDF,          },
};

//aes-cmac, tdes-cmac, hmac-sha1, hmac-sha224, hmac-sha256, hmac-sha384, hmac-sha512
const CK_CHAR ARG_DERIVE_KDF_TYPE_TDES_CMAC[] = "tdes-cmac";
const CK_CHAR ARG_DERIVE_KDF_TYPE_AES_CMAC[] = "aes-cmac";
const CK_CHAR ARG_DERIVE_KDF_TYPE_HMAC_SHA1[] = "hmac-sha1";
const CK_CHAR ARG_DERIVE_KDF_TYPE_HMAC_SHA224[] = "hmac-sha224";
const CK_CHAR ARG_DERIVE_KDF_TYPE_HMAC_SHA256[] = "hmac-sha256";
const CK_CHAR ARG_DERIVE_KDF_TYPE_HMAC_SHA384[] = "hmac-sha384";
const CK_CHAR ARG_DERIVE_KDF_TYPE_HMAC_SHA512[] = "hmac-sha512";

#define SIZE_KDF_TYPE_TABLE     DIM(kdf_type)
const P11_KDF_TYPE kdf_type[] = {
   {(CK_CHAR_PTR)&ARG_DERIVE_KDF_TYPE_TDES_CMAC,               CK_NIST_PRF_KDF_DES3_CMAC},
   {(CK_CHAR_PTR)&ARG_DERIVE_KDF_TYPE_AES_CMAC,                CK_NIST_PRF_KDF_AES_CMAC},
   {(CK_CHAR_PTR)&ARG_DERIVE_KDF_TYPE_HMAC_SHA1,               CK_NIST_PRF_KDF_HMAC_SHA1},
   {(CK_CHAR_PTR)&ARG_DERIVE_KDF_TYPE_HMAC_SHA224,             CK_NIST_PRF_KDF_HMAC_SHA224},
   {(CK_CHAR_PTR)&ARG_DERIVE_KDF_TYPE_HMAC_SHA256,             CK_NIST_PRF_KDF_HMAC_SHA256},
   {(CK_CHAR_PTR)&ARG_DERIVE_KDF_TYPE_HMAC_SHA384,             CK_NIST_PRF_KDF_HMAC_SHA384},
   {(CK_CHAR_PTR)&ARG_DERIVE_KDF_TYPE_HMAC_SHA512,             CK_NIST_PRF_KDF_HMAC_SHA512},

};

const CK_CHAR ARG_DERIVE_KDF_SCHEME_1[] = "scheme1";
const CK_CHAR ARG_DERIVE_KDF_SCHEME_2[] = "scheme2";
const CK_CHAR ARG_DERIVE_KDF_SCHEME_3[] = "scheme3";
const CK_CHAR ARG_DERIVE_KDF_SCHEME_4[] = "scheme4";
const CK_CHAR ARG_DERIVE_KDF_SCHEME_SCP03[] = "scp03";
const CK_CHAR ARG_DERIVE_KDF_SCHEME_HID[] = "hid";

#define SIZE_KDF_SCHEME_TABLE     DIM(kdf_scheme)
const P11_KDF_SCHEME kdf_scheme[] = {
   {(CK_CHAR_PTR)&ARG_DERIVE_KDF_SCHEME_1,               LUNA_PRF_KDF_ENCODING_SCHEME_1 },
   {(CK_CHAR_PTR)&ARG_DERIVE_KDF_SCHEME_2,               LUNA_PRF_KDF_ENCODING_SCHEME_2 },
   {(CK_CHAR_PTR)&ARG_DERIVE_KDF_SCHEME_3,               LUNA_PRF_KDF_ENCODING_SCHEME_3 },
   {(CK_CHAR_PTR)&ARG_DERIVE_KDF_SCHEME_4,               LUNA_PRF_KDF_ENCODING_SCHEME_4 },
   {(CK_CHAR_PTR)&ARG_DERIVE_KDF_SCHEME_SCP03,           LUNA_PRF_KDF_ENCODING_SCHEME_SCP03 },
   {(CK_CHAR_PTR)&ARG_DERIVE_KDF_SCHEME_HID,             LUNA_PRF_KDF_ENCODING_SCHEME_HID_KD },
};


#define SIZE_HASH_ALGO_TABLE     DIM(hash_algo)
const P11_HASH_MECH hash_algo[] = {
    {(CK_CHAR_PTR)&ARG_ALG_SHA1,                CKM_SHA_1,           CKG_MGF1_SHA1,    KEY_TYPE_HASH | KEY_TYPE_IMPORT_EXPORTKEY | KEY_TYPE_ENCRYPT},
    {(CK_CHAR_PTR)&ARG_ALG_SHA224,              CKM_SHA224,          0,                KEY_TYPE_HASH},
    {(CK_CHAR_PTR)&ARG_ALG_SHA256,              CKM_SHA256,          CKG_MGF1_SHA256,  KEY_TYPE_HASH | KEY_TYPE_IMPORT_EXPORTKEY | KEY_TYPE_ENCRYPT},
    {(CK_CHAR_PTR)&ARG_ALG_SHA384,              CKM_SHA384,          CKG_MGF1_SHA384,  KEY_TYPE_HASH | KEY_TYPE_IMPORT_EXPORTKEY | KEY_TYPE_ENCRYPT},
    {(CK_CHAR_PTR)&ARG_ALG_SHA512,              CKM_SHA512,          CKG_MGF1_SHA512,  KEY_TYPE_HASH | KEY_TYPE_IMPORT_EXPORTKEY | KEY_TYPE_ENCRYPT},
    {(CK_CHAR_PTR)&ARG_ALG_SHA3_224,            CKM_SHA3_224,        0,                KEY_TYPE_HASH},
    {(CK_CHAR_PTR)&ARG_ALG_SHA3_256,            CKM_SHA3_256,        0,                KEY_TYPE_HASH},
    {(CK_CHAR_PTR)&ARG_ALG_SHA3_284,            CKM_SHA3_384,        0,                KEY_TYPE_HASH},
    {(CK_CHAR_PTR)&ARG_ALG_SHA3_512,            CKM_SHA3_512,        0,                KEY_TYPE_HASH},
};

//aes-cmac, tdes-cmac, hmac-sha1, hmac-sha224, hmac-sha256, hmac-sha384, hmac-sha512
const CK_CHAR ARG_KCV_METHOD_PKCS11[] = "pkcs11";
const CK_CHAR ARG_KCV_METHOD_PCI[] = "pci";
const CK_CHAR ARG_KCV_METHOD_GP[] = "gp";
const CK_CHAR ARG_KCV_METHOD_HMAC_SHA2_56[] = "hmac-sha-256";

#define SIZE_KCV_TYPE_TABLE     DIM(kcv_type)
const P11_KCV_TYPE kcv_type[] = {
   {(CK_CHAR_PTR)&ARG_KCV_METHOD_PKCS11,           KCV_PKCS11},
   {(CK_CHAR_PTR)&ARG_KCV_METHOD_PCI,              KCV_PCI},
   {(CK_CHAR_PTR)&ARG_KCV_METHOD_GP,               KCV_GP},
   {(CK_CHAR_PTR)&ARG_KCV_METHOD_HMAC_SHA2_56,     KCV_HMAC_256},

};


const CK_CHAR ARG_CKA_APPLICATION[] = "application";
const CK_CHAR ARG_CKA_ID[] = "id";
const CK_CHAR ARG_CKA_VALUE[] = "value";

#define SIZE_ATTR_TYPE_TABLE     DIM(attr_type)
const P11_ATTR_TYPE attr_type[] = {
   {(CK_CHAR_PTR)&ARG_CKA_APPLICATION,    CKA_APPLICATION},
   {(CK_CHAR_PTR)&ARG_CKA_ID,             CKA_ID},
   {(CK_CHAR_PTR)&ARG_CKA_VALUE,          CKA_VALUE},

};

const CK_CHAR ML_DSA_ML_44[] = "ML-DSA-44";
const CK_CHAR ML_DSA_ML_65[] = "ML-DSA-65";
const CK_CHAR ML_DSA_ML_87[] = "ML-DSA-87";

/***   ML DSA ****/
#define SIZE_P11_ML_DSA_KEYSIZE_TABLE     DIM(ml_dsa_publickeysize)
const P11_ML_DSA_KEY_SIZE ml_dsa_publickeysize[] = {
   {ML_DSA_44_PUBLIC_KEY_SIZE,  ML_DSA_44_PRIVATE_KEY_SIZE,          CKP_ML_DSA_44,             (CK_CHAR_PTR)&ML_DSA_ML_44},
   {ML_DSA_65_PUBLIC_KEY_SIZE,  ML_DSA_65_PRIVATE_KEY_SIZE,          CKP_ML_DSA_65,             (CK_CHAR_PTR)&ML_DSA_ML_65},
   {ML_DSA_87_PUBLIC_KEY_SIZE,  ML_DSA_87_PRIVATE_KEY_SIZE,          CKP_ML_DSA_87,             (CK_CHAR_PTR)&ML_DSA_ML_87},

};

/******************** pkcs11 error *********************/
typedef struct pkcs11_error
{
   const CK_ULONG uError;
   const CK_CHAR_PTR sErrorString;
}PKCS11_ERROR;

const CK_CHAR UNKNOWN_ERROR[] = "Unknown Error";

#define SIZE_ERROR_TABLE         DIM(error_table)
PKCS11_ERROR error_table[] =
{
   {CKR_OK,                         "CKR_OK"},
   {CKR_CANCEL,                     "CKR_CANCEL"},
   {CKR_HOST_MEMORY,                "CKR_HOST_MEMORY"},
   {CKR_SLOT_ID_INVALID,            "CKR_SLOT_ID_INVALID"},
   {CKR_GENERAL_ERROR,              "CKR_GENERAL_ERROR"},
   {CKR_FUNCTION_FAILED,            "CKR_FUNCTION_FAILED"},
   {CKR_ARGUMENTS_BAD,              "CKR_ARGUMENTS_BAD"},
   {CKR_NO_EVENT,                   "CKR_NO_EVENT"},
   {CKR_NEED_TO_CREATE_THREADS,     "CKR_NEED_TO_CREATE_THREADS"},
   {CKR_CANT_LOCK,                  "CKR_CANT_LOCK"},
   {CKR_ATTRIBUTE_READ_ONLY,        "CKR_ATTRIBUTE_READ_ONLY"},
   {CKR_ATTRIBUTE_SENSITIVE,        "CKR_ATTRIBUTE_SENSITIVE"},
   {CKR_ATTRIBUTE_TYPE_INVALID,     "CKR_ATTRIBUTE_TYPE_INVALID"},
   {CKR_ATTRIBUTE_VALUE_INVALID,    "CKR_ATTRIBUTE_VALUE_INVALID"},
   {CKR_ACTION_PROHIBITED,          "CKR_ACTION_PROHIBITED"},
   {CKR_DATA_INVALID,               "CKR_DATA_INVALID"},
   {CKR_DATA_LEN_RANGE,             "CKR_DATA_LEN_RANGE"},
   {CKR_DEVICE_ERROR,               "CKR_DEVICE_ERROR"},
   {CKR_DEVICE_MEMORY,              "CKR_DEVICE_MEMORY"},
   {CKR_DEVICE_REMOVED,             "CKR_DEVICE_REMOVED"},
   {CKR_ENCRYPTED_DATA_INVALID,     "CKR_ENCRYPTED_DATA_INVALID"},
   {CKR_ENCRYPTED_DATA_LEN_RANGE,   "CKR_ENCRYPTED_DATA_LEN_RANGE"},
   {CKR_AEAD_DECRYPT_FAILED,        "CKR_AEAD_DECRYPT_FAILED"},
   {CKR_FUNCTION_CANCELED,          "CKR_FUNCTION_CANCELED"},
   {CKR_FUNCTION_NOT_PARALLEL,      "CKR_FUNCTION_NOT_PARALLEL"},
   {CKR_FUNCTION_NOT_SUPPORTED,     "CKR_FUNCTION_NOT_SUPPORTED"},
   {CKR_KEY_HANDLE_INVALID,         "CKR_KEY_HANDLE_INVALID"},
   {CKR_KEY_SIZE_RANGE,             "CKR_KEY_SIZE_RANGE"},
   {CKR_KEY_TYPE_INCONSISTENT,      "CKR_KEY_TYPE_INCONSISTENT"},
   {CKR_KEY_NOT_NEEDED,             "CKR_KEY_NOT_NEEDED"},
   {CKR_KEY_CHANGED,                "CKR_KEY_CHANGED"},
   {CKR_KEY_NEEDED,                 "CKR_KEY_NEEDED"},
   {CKR_KEY_INDIGESTIBLE,           "CKR_KEY_INDIGESTIBLE"},
   {CKR_KEY_FUNCTION_NOT_PERMITTED, "CKR_KEY_FUNCTION_NOT_PERMITTED"},
   {CKR_KEY_NOT_WRAPPABLE,          "CKR_KEY_NOT_WRAPPABLE"},
   {CKR_KEY_UNEXTRACTABLE,          "CKR_KEY_UNEXTRACTABLE"},
   {CKR_MECHANISM_INVALID,          "CKR_MECHANISM_INVALID"},
   {CKR_MECHANISM_PARAM_INVALID,    "CKR_MECHANISM_PARAM_INVALID"},
   {CKR_OBJECT_HANDLE_INVALID,      "CKR_OBJECT_HANDLE_INVALID"},
   {CKR_OPERATION_ACTIVE,           "CKR_OPERATION_ACTIVE"},
   {CKR_OPERATION_NOT_INITIALIZED,  "CKR_OPERATION_NOT_INITIALIZED"},
   {CKR_PIN_INCORRECT,              "CKR_PIN_INCORRECT"},
   {CKR_PIN_INVALID,                "CKR_PIN_INVALID"},
   {CKR_PIN_LEN_RANGE,              "CKR_PIN_LEN_RANGE"},
   {CKR_PIN_EXPIRED,                "CKR_PIN_EXPIRED"},
   {CKR_PIN_LOCKED,                 "CKR_PIN_LOCKED"},
   {CKR_SESSION_CLOSED,             "CKR_SESSION_CLOSED"},
   {CKR_SESSION_COUNT,              "CKR_SESSION_COUNT"},
   {CKR_SESSION_HANDLE_INVALID,     "CKR_SESSION_HANDLE_INVALID"},
   {CKR_SESSION_PARALLEL_NOT_SUPPORTED,"CKR_SESSION_PARALLEL_NOT_SUPPORTED"},
   {CKR_SESSION_READ_ONLY,          "CKR_SESSION_READ_ONLY"},
   {CKR_SESSION_EXISTS,             "CKR_SESSION_EXISTS"},
   {CKR_SESSION_READ_ONLY_EXISTS,   "CKR_SESSION_READ_ONLY_EXISTS"},
   {CKR_SESSION_READ_WRITE_SO_EXISTS,"CKR_SESSION_READ_WRITE_SO_EXISTS"},
   {CKR_SIGNATURE_INVALID,          "CKR_SIGNATURE_INVALID"},
   {CKR_SIGNATURE_LEN_RANGE,        "CKR_SIGNATURE_LEN_RANGE"},
   {CKR_TEMPLATE_INCOMPLETE,        "CKR_TEMPLATE_INCOMPLETE"},
   {CKR_TEMPLATE_INCONSISTENT,      "CKR_TEMPLATE_INCONSISTENT"},
   {CKR_TOKEN_NOT_PRESENT,          "CKR_TOKEN_NOT_PRESENT"},
   {CKR_TOKEN_NOT_RECOGNIZED,       "CKR_TOKEN_NOT_RECOGNIZED"},
   {CKR_TOKEN_WRITE_PROTECTED,      "CKR_TOKEN_WRITE_PROTECTED"},
   {CKR_UNWRAPPING_KEY_HANDLE_INVALID,"CKR_UNWRAPPING_KEY_HANDLE_INVALID"},
   {CKR_UNWRAPPING_KEY_SIZE_RANGE,  "CKR_UNWRAPPING_KEY_SIZE_RANGE"},
   {CKR_UNWRAPPING_KEY_TYPE_INCONSISTENT,"CKR_UNWRAPPING_KEY_TYPE_INCONSISTENT"},
   {CKR_USER_ALREADY_LOGGED_IN,     "CKR_USER_ALREADY_LOGGED_IN"},
   {CKR_USER_NOT_LOGGED_IN,         "CKR_USER_NOT_LOGGED_IN"},
   {CKR_USER_PIN_NOT_INITIALIZED,   "CKR_USER_PIN_NOT_INITIALIZED"},
   {CKR_USER_TYPE_INVALID,          "CKR_USER_TYPE_INVALID"},
   {CKR_USER_ANOTHER_ALREADY_LOGGED_IN,"CKR_USER_ANOTHER_ALREADY_LOGGED_IN"},
   {CKR_USER_TOO_MANY_TYPES ,       "CKR_USER_TOO_MANY_TYPES"},
   {CKR_WRAPPED_KEY_INVALID,        "CKR_WRAPPED_KEY_INVALID"},
   {CKR_WRAPPED_KEY_LEN_RANGE,      "CKR_WRAPPED_KEY_LEN_RANGE"},
   {CKR_WRAPPING_KEY_HANDLE_INVALID,"CKR_WRAPPING_KEY_HANDLE_INVALID"},
   {CKR_WRAPPING_KEY_SIZE_RANGE,    "CKR_WRAPPING_KEY_SIZE_RANGE"},
   {CKR_WRAPPING_KEY_TYPE_INCONSISTENT ,"CKR_WRAPPING_KEY_TYPE_INCONSISTENT"},
   {CKR_RANDOM_SEED_NOT_SUPPORTED,  "CKR_RANDOM_SEED_NOT_SUPPORTED"},
   {CKR_RANDOM_NO_RNG,              "CKR_RANDOM_NO_RNG"},
   {CKR_DOMAIN_PARAMS_INVALID,      "CKR_DOMAIN_PARAMS_INVALID"},
   {CKR_CURVE_NOT_SUPPORTED,        "CKR_CURVE_NOT_SUPPORTED"},
   {CKR_BUFFER_TOO_SMALL,           "CKR_BUFFER_TOO_SMALL" },
   {CKR_SAVED_STATE_INVALID,        "CKR_SAVED_STATE_INVALID" },
   {CKR_INFORMATION_SENSITIVE,      "CKR_INFORMATION_SENSITIVE" },
   {CKR_STATE_UNSAVEABLE,           "CKR_STATE_UNSAVEABLE" },
   {CKR_CRYPTOKI_NOT_INITIALIZED,   "CKR_CRYPTOKI_NOT_INITIALIZED" },
   {CKR_CRYPTOKI_ALREADY_INITIALIZED,"CKR_CRYPTOKI_ALREADY_INITIALIZED" },
   {CKR_MUTEX_BAD,                  "CKR_MUTEX_BAD" },
   {CKR_MUTEX_NOT_LOCKED,           "CKR_MUTEX_NOT_LOCKED" },
   {CKR_NEW_PIN_MODE,               "CKR_NEW_PIN_MODE" },
   {CKR_NEXT_OTP,                   "CKR_NEXT_OTP" },
   {CKR_EXCEEDED_MAX_ITERATIONS,    "CKR_EXCEEDED_MAX_ITERATIONS" },
   {CKR_FIPS_SELF_TEST_FAILED ,     "CKR_FIPS_SELF_TEST_FAILED" },
   {CKR_LIBRARY_LOAD_FAILED,        "CKR_LIBRARY_LOAD_FAILED" },
   {CKR_PIN_TOO_WEAK,               "CKR_PIN_TOO_WEAK" },
   {CKR_PUBLIC_KEY_INVALID,         "CKR_PUBLIC_KEY_INVALID" },
   {CKR_FUNCTION_REJECTED,          "CKR_FUNCTION_REJECTED" },
   {CKR_TOKEN_RESOURCE_EXCEEDED,    "CKR_TOKEN_RESOURCE_EXCEEDED" },
   // luna vendor error code
   {CKR_RC_ERROR,  "CKR_RC_ERROR" },
   {CKR_CONTAINER_HANDLE_INVALID,   "CKR_CONTAINER_HANDLE_INVALID" },
   {CKR_TOO_MANY_CONTAINERS,        "CKR_TOO_MANY_CONTAINERS" },
   {CKR_USER_LOCKED_OUT,            "CKR_USER_LOCKED_OUT" },
   {CKR_CLONING_PARAMETER_ALREADY_EXISTS,  "CKR_CLONING_PARAMETER_ALREADY_EXISTS" },
   {CKR_CLONING_PARAMETER_MISSING,  "CKR_CLONING_PARAMETER_MISSING" },
   {CKR_CERTIFICATE_DATA_MISSING,   "CKR_CERTIFICATE_DATA_MISSING" },
   {CKR_CERTIFICATE_DATA_INVALID,   "CKR_CERTIFICATE_DATA_INVALID" },
   {CKR_ACCEL_DEVICE_ERROR,         "CKR_ACCEL_DEVICE_ERROR" },
   {CKR_WRAPPING_ERROR,             "CKR_WRAPPING_ERROR" },
   {CKR_UNWRAPPING_ERROR,           "CKR_UNWRAPPING_ERROR" },
   {CKR_MAC_MISSING,                "CKR_MAC_MISSING" },
   {CKR_DAC_POLICY_PID_MISMATCH,    "CKR_DAC_POLICY_PID_MISMATCH" },
   {CKR_DAC_MISSING,                "CKR_DAC_MISSING" },
   {CKR_BAD_DAC,                    "CKR_BAD_DAC" },
   {CKR_SSK_MISSING ,               "CKR_SSK_MISSING" },
   {CKR_BAD_MAC,                    "CKR_BAD_MAC" },
   {CKR_DAK_MISSING,                "CKR_DAK_MISSING" },
   {CKR_BAD_DAK,                    "CKR_BAD_DAK" },
   {CKR_SIM_AUTHORIZATION_FAILED,   "CKR_SIM_AUTHORIZATION_FAILED" },
   {CKR_SIM_VERSION_UNSUPPORTED,    "CKR_SIM_VERSION_UNSUPPORTED" },
   {CKR_SIM_CORRUPT_DATA,           "CKR_SIM_CORRUPT_DATA" },
   {CKR_USER_NOT_AUTHORIZED,        "CKR_USER_NOT_AUTHORIZED" },
   {CKR_MAX_OBJECT_COUNT_EXCEEDED,  "CKR_MAX_OBJECT_COUNT_EXCEEDED" },
   {CKR_SO_LOGIN_FAILURE_THRESHOLD, "CKR_SO_LOGIN_FAILURE_THRESHOLD" },
   {CKR_SIM_AUTHFORM_INVALID,       "CKR_SIM_AUTHFORM_INVALID" },
   {CKR_CITS_DAK_MISSING,           "CKR_CITS_DAK_MISSING" },
   {CKR_UNABLE_TO_CONNECT,          "CKR_UNABLE_TO_CONNECT" },
   {CKR_UNABLE_TO_CONNECT,          "CKR_UNABLE_TO_CONNECT" },
   {CKR_CALLBACK_ERROR,             "CKR_CALLBACK_ERROR" },
   {CKR_SECURITY_PARAMETER_MISSING, "CKR_SECURITY_PARAMETER_MISSING" },
   {CKR_SP_TIMEOUT,                 "CKR_SP_TIMEOUT" },
   {CKR_TIMEOUT,                    "CKR_TIMEOUT" },
   {CKR_ECC_UNKNOWN_CURVE,          "CKR_ECC_UNKNOWN_CURVE" },
   {CKR_MTK_ZEROIZED,               "CKR_MTK_ZEROIZED" },
   {CKR_MTK_STATE_INVALID,          "CKR_MTK_STATE_INVALID" },
   {CKR_INVALID_ENTRY_TYPE,         "CKR_INVALID_ENTRY_TYPE" },
   {CKR_MTK_SPLIT_INVALID,          "CKR_RC_ERROR" },
   {CKR_HSM_STORAGE_FULL,           "CKR_HSM_STORAGE_FULL" },
   {CKR_DEVICE_TIMEOUT,             "CKR_DEVICE_TIMEOUT" },
   {CKR_CONTAINER_OBJECT_STORAGE_FULL, "CKR_CONTAINER_OBJECT_STORAGE_FULL" },
   {CKR_PED_CLIENT_NOT_RUNNING,     "CKR_PED_CLIENT_NOT_RUNNING" },
   {CKR_PED_UNPLUGGED,              "CKR_PED_UNPLUGGED" },
   {CKR_ECC_POINT_INVALID,          "CKR_ECC_POINT_INVALID" },
   {CKR_OPERATION_NOT_ALLOWED ,     "CKR_OPERATION_NOT_ALLOWED" },
   {CKR_LICENSE_CAPACITY_EXCEEDED,  "CKR_LICENSE_CAPACITY_EXCEEDED" },
   {CKR_LOG_FILE_NOT_OPEN,          "CKR_LOG_FILE_NOT_OPEN" },
   {CKR_LOG_FILE_WRITE_ERROR,       "CKR_LOG_FILE_WRITE_ERROR" },
   {CKR_LOG_BAD_FILE_NAME,          "CKR_LOG_BAD_FILE_NAME" },
   {CKR_LOG_FULL,                   "CKR_LOG_FULL" },
   {CKR_LOG_NO_KCV,                 "CKR_LOG_NO_KCV" },
   {CKR_LOG_BAD_RECORD_HMAC,        "CKR_LOG_BAD_RECORD_HMAC" },
   {CKR_LOG_BAD_TIME,               "CKR_LOG_BAD_TIME" },
   {CKR_LOG_AUDIT_NOT_INITIALIZED,  "CKR_LOG_AUDIT_NOT_INITIALIZED" },
   {CKR_LOG_AUDIT_NOT_INITIALIZED,  "CKR_LOG_AUDIT_NOT_INITIALIZED" },
   {CKR_AUDIT_LOGIN_TIMEOUT_IN_PROGRESS,  "CKR_AUDIT_LOGIN_TIMEOUT_IN_PROGRESS" },
   {CKR_AUDIT_LOGIN_FAILURE_THRESHOLD,  "CKR_AUDIT_LOGIN_FAILURE_THRESHOLD" },
   {CKR_INVALID_FUF_TARGET,         "CKR_INVALID_FUF_TARGET" },
   {CKR_INVALID_FUF_HEADER,         "CKR_INVALID_FUF_HEADER" },
   {CKR_INVALID_FUF_VERSION,        "CKR_INVALID_FUF_VERSION" },
   {CKR_ECC_ECC_RESULT_AT_INF,      "CKR_ECC_ECC_RESULT_AT_INF" },
   {CKR_AGAIN,                      "CKR_AGAIN" },
   {CKR_TOKEN_COPIED,               "CKR_TOKEN_COPIED" },
   {CKR_SLOT_NOT_EMPTY,             "CKR_SLOT_NOT_EMPTY" },
   {CKR_USER_ALREADY_ACTIVATED,     "CKR_USER_ALREADY_ACTIVATED" },
   {CKR_CHALLENGE_INCORRECT,        "CKR_CHALLENGE_INCORRECT" },
   {CKR_ACCESS_ID_INVALID,          "CKR_ACCESS_ID_INVALID" },
   { CKR_ACCESS_ID_ALREADY_EXISTS,  "CKR_ACCESS_ID_ALREADY_EXISTS" },
   {CKR_KEY_NOT_KEKABLE,            "CKR_KEY_NOT_KEKABLE" },
   {CKR_MECHANISM_INVALID_FOR_FP,   "CKR_MECHANISM_INVALID_FOR_FP" },
   {CKR_OPERATION_INVALID_FOR_FP,   "CKR_OPERATION_INVALID_FOR_FP" },
   {CKR_SESSION_HANDLE_INVALID_FOR_FP,"CKR_SESSION_HANDLE_INVALID_FOR_FP" },
   {CKR_CMD_NOT_ALLOWED_HSM_IN_TRANSPORT,"CKR_CMD_NOT_ALLOWED_HSM_IN_TRANSPORT" },
   {CKR_OBJECT_ALREADY_EXISTS,      "CKR_OBJECT_ALREADY_EXISTS" },
   {CKR_PARTITION_ROLE_DESC_VERSION_INVALID,"CKR_PARTITION_ROLE_DESC_VERSION_INVALID" },
   {CKR_PARTITION_ROLE_POLICY_VERSION_INVALID,"CKR_PARTITION_ROLE_POLICY_VERSION_INVALID" },
   {CKR_PARTITION_ROLE_POLICY_SET_VERSION_INVALID,"CKR_PARTITION_ROLE_POLICY_SET_VERSION_INVALID" },
   {CKR_REKEK_KEY,                  "CKR_REKEK_KEY" },
   {CKR_KEK_RETRY_FAILURE,          "CKR_KEK_RETRY_FAILURE" },
   {CKR_RNG_RESEED_TOO_EARLY,       "CKR_RNG_RESEED_TOO_EARLY" },
   {CKR_HSM_TAMPERED,               "CKR_HSM_TAMPERED" },
   {CKR_CONFIG_CHANGE_ILLEGAL,      "CKR_CONFIG_CHANGE_ILLEGAL" },
   {CKR_SESSION_CONTEXT_NOT_ALLOCATED,"CKR_SESSION_CONTEXT_NOT_ALLOCATED" },
   {CKR_SESSION_CONTEXT_ALREADY_ALLOCATED,"CKR_SESSION_CONTEXT_ALREADY_ALLOCATED" },
   {CKR_INVALID_BL_ITB_AUTH_HEADER, "CKR_INVALID_BL_ITB_AUTH_HEADER" },
   {CKR_POLICY_ID_INVALID,          "CKR_POLICY_ID_INVALID" },
   {CKR_CONFIG_ILLEGAL,             "CKR_CONFIG_ILLEGAL" },
   {CKR_CONFIG_FAILS_DEPENDENCIES,  "CKR_CONFIG_FAILS_DEPENDENCIES" },
   {CKR_CERTIFICATE_TYPE_INVALID,   "CKR_CERTIFICATE_TYPE_INVALID" },
};

/******************** pkcs11 attrbute *********************/
const CK_CHAR UNKNOWN_ATTRIBUTE[] = "Unknown Attribute";
typedef struct attribute_name
{
   const CK_ATTRIBUTE_TYPE ckAttribute;
   const CK_CHAR_PTR sAttributeName;
}ATTRIBUTE_NAME;

#define SIZE_ATTRIBUTE_TABLE         DIM(attribute_table)
ATTRIBUTE_NAME attribute_table[] =
{
   {CKA_CLASS,                "CKA_CLASS" },
   {CKA_TOKEN,                "CKA_TOKEN" },
   {CKA_PRIVATE,              "CKA_PRIVATE" },
   {CKA_LABEL,                "CKA_LABEL" },
   {CKA_UNIQUE_ID,            "CKA_UNIQUE_ID" },
   {CKA_APPLICATION,          "CKA_APPLICATION" },
   {CKA_VALUE,                "CKA_VALUE" },
   {CKA_OBJECT_ID,            "CKA_OBJECT_ID" },
   {CKA_CERTIFICATE_TYPE,     "CKA_CERTIFICATE_TYPE" },
   {CKA_ISSUER,               "CKA_ISSUER" },
   {CKA_SERIAL_NUMBER,        "CKA_SERIAL_NUMBER" },
   {CKA_AC_ISSUER,            "CKA_AC_ISSUER" },
   {CKA_OWNER,                "CKA_OWNER" },
   {CKA_ATTR_TYPES,           "CKA_ATTR_TYPES" },
   {CKA_TRUSTED,              "CKA_TRUSTED" },
   {CKA_CERTIFICATE_CATEGORY, "CKA_CERTIFICATE_CATEGORY" },
   {CKA_JAVA_MIDP_SECURITY_DOMAIN,   "CKA_JAVA_MIDP_SECURITY_DOMAIN" },
   {CKA_URL,                  "CKA_URL" },
   {CKA_HASH_OF_SUBJECT_PUBLIC_KEY,   "CKA_HASH_OF_SUBJECT_PUBLIC_KEY" },
   {CKA_HASH_OF_ISSUER_PUBLIC_KEY,   "CKA_HASH_OF_ISSUER_PUBLIC_KEY" },
   {CKA_NAME_HASH_ALGORITHM,   "CKA_NAME_HASH_ALGORITHM" },
   {CKA_CHECK_VALUE,          "CKA_CHECK_VALUE" },
   {CKA_KEY_TYPE,             "CKA_KEY_TYPE" },
   {CKA_SUBJECT,              "CKA_SUBJECT" },
   {CKA_ID,                   "CKA_ID" },
   {CKA_SENSITIVE,            "CKA_SENSITIVE" },
   {CKA_ENCRYPT,              "CKA_ENCRYPT" },
   {CKA_DECRYPT,              "CKA_DECRYPT" },
   {CKA_WRAP,                 "CKA_WRAP" },
   {CKA_UNWRAP,               "CKA_SIGN" },
   {CKA_SIGN,                 "CKA_SIGN" },
   {CKA_SIGN_RECOVER,         "CKA_SIGN_RECOVER" },
   {CKA_VERIFY,               "CKA_VERIFY" },
   {CKA_VERIFY_RECOVER,       "CKA_VERIFY_RECOVER" },
   {CKA_DERIVE,               "CKA_DERIVE" },
   {CKA_START_DATE,           "CKA_START_DATE" },
   {CKA_END_DATE,             "CKA_END_DATE" },
};

/*
    FUNCTION:        CK_CHAR_PTR P11Util_DisplayClassName(CK_ULONG u32Class)
*/
CK_CHAR_PTR P11Util_DisplayErrorName(CK_ULONG uErrorCode)
{
   CK_ULONG uLoop;

   // loop on all rsa mech structure
   for (uLoop = 0; uLoop < SIZE_ERROR_TABLE; uLoop++)
   {
      if (error_table[uLoop].uError == uErrorCode)
      {
         return error_table[uLoop].sErrorString;
      }
   }
   return (CK_CHAR_PTR)UNKNOWN_ERROR;
}

/*
    FUNCTION:        CK_CHAR_PTR P11Util_DisplayClassName(CK_ULONG u32Class)
*/
CK_CHAR_PTR P11Util_DisplayAttributeName(CK_ATTRIBUTE_TYPE ckAttribute)
{
   CK_ULONG uLoop;

   // loop on all rsa mech structure
   for (uLoop = 0; uLoop < SIZE_ATTRIBUTE_TABLE; uLoop++)
   {
      if (attribute_table[uLoop].ckAttribute == ckAttribute)
      {
         return attribute_table[uLoop].sAttributeName;
      }
   }
   return (CK_CHAR_PTR)UNKNOWN_ATTRIBUTE;
}

/*
    FUNCTION:        CK_CHAR_PTR P11Util_DisplayClassName(CK_ULONG u32Class)
*/
CK_CHAR_PTR P11Util_DisplayClassName(CK_OBJECT_CLASS u32Class)
{
   // check the class integer value and returns the class corresponding string
   switch (u32Class)
   {
   case CKO_DATA:
      return (CK_CHAR_PTR)CLASS_DATA;
   case CKO_CERTIFICATE:
      return (CK_CHAR_PTR)CLASS_CERTIFICATE;
   case CKO_PUBLIC_KEY:
      return (CK_CHAR_PTR)CLASS_PUBLICKEY;
   case CKO_PRIVATE_KEY:
      return (CK_CHAR_PTR)CLASS_PRIVATEKEY;
   case CKO_SECRET_KEY:
      return (CK_CHAR_PTR)CLASS_SECRETKEY;
   default:
      return (CK_CHAR_PTR)CLASS_UNKNOWN;
   }
}

/*
    FUNCTION:        CK_CHAR_PTR P11Util_DisplayClassName(CK_ULONG u32Class)
*/
CK_CHAR_PTR P11Util_DisplayKeyTypeName(CK_KEY_TYPE keytype)
{
   CK_BYTE u8Loop;

   // loop on all rsa mech structure
   for (u8Loop = 0; u8Loop < SIZE_KEYGEN_SUPPORTED_TYPE_TABLE; u8Loop++)
   {
      if (arg_keygen_supported_type[u8Loop].cktype == keytype)
      {
         if (arg_keygen_supported_type[u8Loop].uFlag & KEY_TYPE_DISPLAY)
         {
            return arg_keygen_supported_type[u8Loop].sKeyTypeName;
         }

      }
   };
   return (CK_CHAR_PTR)CLASS_UNKNOWN;
}


/*
    FUNCTION:        CK_CHAR_PTR P11Util_DisplayClassName(CK_ULONG P11Util_DisplayBooleanName)
*/
CK_CHAR_PTR P11Util_DisplayBooleanName(CK_BBOOL ckbool)
{
   if (ckbool == TRUE)
   {
      return (CK_CHAR_PTR)STRING_TRUE;
   }
   return (CK_CHAR_PTR)STRING_FALSE;
}


/*
    FUNCTION:        void P11Util_DisplayDate(CK_CHAR_PTR ByteArray, CK_DATE Date, CK_LONG Length)
*/
void P11Util_DisplayDate(CK_CHAR_PTR Name, CK_DATE* Date, CK_LONG Length)
{
   printf(Name);
   if (Length != 0)
   {
      printf("Day:%s, Month:%s, Year:%s", Date->day, Date->month, Date->year);
   }
   printf("\n");
}

/*
    FUNCTION:        void P11Util_DisplayOIDName(CK_CHAR_PTR sOID, CK_BYTE bOIDLen)
*/
void P11Util_DisplayOIDName(CK_CHAR_PTR sOID, CK_BYTE bOIDLen)
{
   CK_BYTE u8Loop;

   // loop on all curve structure
   for (u8Loop = 0; u8Loop < SIZE_ECC_CURVE_TABLE; u8Loop++)
   {
      // check if oid length match
      if (ecc_curve_oid[u8Loop].oidLen == bOIDLen)
      {
         // if curve name match, return OID name
         if (memcmp(ecc_curve_oid[u8Loop].oid, sOID, bOIDLen) == 0)
         {
            printf("CurveOIDName=%s\n", ecc_curve_oid[u8Loop].sCurveName);
            return;
         }
      }

   };
}

/*
    FUNCTION:        CK_MECHANISM_TYPE P11Util_GetRSAGenMechParam(CK_CHAR_PTR sKeyType)
*/
CK_MECHANISM_TYPE P11Util_GetRSAGenMechParam(CK_CHAR_PTR sKeyType)
{
   CK_BYTE u8Loop;

   // loop on all rsa mech structure
   for (u8Loop = 0; u8Loop < SIZE_RSA_MECH_TABLE; u8Loop++)
   {
      // if curve name match, return OID
      if (strcmp(p11_rsa_mech[u8Loop].sMechName, sKeyType) == 0)
      {
         return p11_rsa_mech[u8Loop].ckMechType;
      }
   };

   return 0xFFFFFFFF;
}

/*
    FUNCTION:        void P11Util_DisplaySupportedRSAGenMechParam()
*/
void P11Util_DisplaySupportedRSAGenMechParam()
{
   CK_BYTE u8Loop;

   printf("Supported RSA key gen mecanism : \n");
   // loop on all structure
   for (u8Loop = 0; u8Loop < SIZE_RSA_MECH_TABLE; u8Loop++)
   {
      printf("-> %s\n", p11_rsa_mech[u8Loop].sMechName);
   }
}

/*
    FUNCTION:        CK_MECHANISM_TYPE P11Util_GetDHGenMechParam(CK_CHAR_PTR sKeyType)
*/
CK_MECHANISM_TYPE P11Util_GetDHGenMechParam(CK_CHAR_PTR sKeyType)
{
   CK_BYTE u8Loop;

   // loop on all rsa mech structure
   for (u8Loop = 0; u8Loop < SIZE_DH_MECH_TABLE; u8Loop++)
   {
      // if curve name match, return OID
      if (strcmp(p11_dh_mech[u8Loop].sMechName, sKeyType) == 0)
      {
         return p11_dh_mech[u8Loop].ckMechType;
      }
   };

   return 0xFFFFFFFF;
}

/*
    FUNCTION:        void P11Util_DisplaySupportedDHGenMechParam()
*/
void P11Util_DisplaySupportedDHGenMechParam()
{
   CK_BYTE u8Loop;

   printf("Supported DH key gen mecanism : \n");
   // loop on all structure
   for (u8Loop = 0; u8Loop < SIZE_DH_MECH_TABLE; u8Loop++)
   {
      printf("-> %s\n", p11_dh_mech[u8Loop].sMechName);
   }
}

/*
    FUNCTION:        CK_KEY_TYPE P11Util_GetCKType(CK_CHAR_PTR sKeyType, CK_ULONG uFlag)
*/
CK_KEY_TYPE P11Util_GetCKType(CK_CHAR_PTR sKeyType, CK_ULONG uFlag)
{
   CK_BYTE u8Loop;

   // loop on all rsa mech structure
   for (u8Loop = 0; u8Loop < SIZE_KEYGEN_SUPPORTED_TYPE_TABLE; u8Loop++)
   {
      // if curve name match, return OID
      if (strcmp(arg_keygen_supported_type[u8Loop].sKeyTypeName, sKeyType) == 0)
      {
         if(arg_keygen_supported_type[u8Loop].uFlag & uFlag)
         {
            return arg_keygen_supported_type[u8Loop].cktype;
         }
      }
   };

   return CK_NULL_ELEMENT;
}

/*
    FUNCTION:        CK_OBJECT_CLASS P11Util_GetClassFromCKType(CK_CHAR_PTR sKeyType, CK_ULONG uFlag)
*/
CK_OBJECT_CLASS P11Util_GetClassFromCKType(CK_CHAR_PTR sKeyType, CK_ULONG uFlag)
{
   CK_BYTE u8Loop;

   // loop on all structure
   for (u8Loop = 0; u8Loop < SIZE_KEYGEN_SUPPORTED_TYPE_TABLE; u8Loop++)
   {
      // if curve name match, return OID
      if (strcmp(arg_keygen_supported_type[u8Loop].sKeyTypeName, sKeyType) == 0)
      {
         if (arg_keygen_supported_type[u8Loop].uFlag & uFlag)
         {
            return arg_keygen_supported_type[u8Loop].ckClass;
         }
      }
   };

   return CK_NULL_ELEMENT;
}
/*
    FUNCTION:        void P11Util_DisplaySupportedKeyType()
*/
void P11Util_DisplaySupportedKeyType(CK_ULONG uFlag)
{
   CK_BYTE u8Loop;

   printf("Supported key type : \n");
   // loop on all structure
   for (u8Loop = 0; u8Loop < SIZE_KEYGEN_SUPPORTED_TYPE_TABLE; u8Loop++)
   {
      if (arg_keygen_supported_type[u8Loop].uFlag & uFlag)
      {
         printf("-> %s\n", arg_keygen_supported_type[u8Loop].sKeyTypeName);
      }
   }
}

/*
    FUNCTION:        CK_OBJECT_CLASS P11Util_GetClassFromCKType(CK_CHAR_PTR sKeyType)
*/
CK_OBJECT_CLASS P11Util_GetClass(CK_CHAR_PTR sKeyClass)
{
   CK_BYTE u8Loop;

   // loop on all structure
   for (u8Loop = 0; u8Loop < SIZE_ARG_KEY_CLASS; u8Loop++)
   {
      // if curve name match, return OID
      if (strcmp(arg_keyclass[u8Loop].sParamName, sKeyClass) == 0)
      {
         return arg_keyclass[u8Loop].ckClass;
      }
   };

   return CK_NULL_ELEMENT;
}

/*
    FUNCTION:        void P11Util_DisplaySupportedClass()
*/
void P11Util_DisplaySupportedClass()
{
   CK_BYTE u8Loop;

   printf("Supported key class : \n");
   // loop on all structure
   for (u8Loop = 0; u8Loop < SIZE_ARG_KEY_CLASS; u8Loop++)
   {
      printf("-> %s\n", arg_keyclass[u8Loop].sParamName);
   }
}

/*
    FUNCTION:        P11_RSA_EXP* P11Util_GetPublicExpParam(CK_CHAR_PTR sHash)
*/
P11_RSA_EXP* P11Util_GetPublicExpParam(CK_CHAR_PTR sPublicExp)
{
   CK_BYTE u8Loop;

   // loop on all key type structure
   for (u8Loop = 0; u8Loop < SIZE_ECC_CURVE_TABLE; u8Loop++)
   {
      // if curve name match, return OID
      if (strcmp(rsa_public_exp[u8Loop].sExpName, sPublicExp) == 0)
      {
         return (P11_RSA_EXP*)&rsa_public_exp[u8Loop];
      }
   };

   return NULL;
}

/*
    FUNCTION:        void P11Util_DisplaySupportedPublicExp()
*/
void P11Util_DisplaySupportedPublicExp()
{
   CK_BYTE u8Loop;

   printf("Supported public exponant value : \n");
   // loop on all structure
   for (u8Loop = 0; u8Loop < SIZE_RSA_PUBEXP_TABLE; u8Loop++)
   {
      printf("-> %s\n", rsa_public_exp[u8Loop].sExpName);
   }
}

/*
    FUNCTION:        P11_ECC_OID* P11Util_GetEcCurveOIDParam(CK_CHAR_PTR sCurveName)
*/
P11_ECC_OID* P11Util_GetEcCurveOIDParam(CK_CHAR_PTR sCurveName)
{
   CK_BYTE u8Loop;

   // loop on all curve structure
   for (u8Loop = 0; u8Loop < SIZE_ECC_CURVE_TABLE; u8Loop++)
   {
      // if curve name match, return OID
      if (strcmp(ecc_curve_oid[u8Loop].sCurveName, sCurveName) == 0)
      {
         return (P11_ECC_OID*)&ecc_curve_oid[u8Loop];
      }
   };
   return NULL;
}

/*
    FUNCTION:        P11_ECC_OID* P11Util_GetEcCurveOID(CK_CHAR_PTR sOid, CK_ULONG sOID_Size)
*/
P11_ECC_OID* P11Util_GetEcCurveOID(CK_CHAR_PTR sOid, CK_ULONG sOID_Size)
{
   CK_BYTE u8Loop;

   // loop on all curve structure
   for (u8Loop = 0; u8Loop < SIZE_ECC_CURVE_TABLE; u8Loop++)
   {
      if (sOID_Size == ecc_curve_oid[u8Loop].oidLen)
      {
         // if curve name match, return OID
         if (memcmp(ecc_curve_oid[u8Loop].oid, sOid, sOID_Size) == 0)
         {
            return (P11_ECC_OID*)&ecc_curve_oid[u8Loop];
         }
      }
   };
   return NULL;
}

/*
    FUNCTION:        void P11Util_DisplaySupportedCurveName(CK_KEY_TYPE sKeyType)
*/
void P11Util_DisplaySupportedCurveName(CK_KEY_TYPE sKeyType)
{
   CK_BYTE u8Loop;

   printf("Supported public exponant value : \n");
   // loop on all structure
   for (u8Loop = 0; u8Loop < SIZE_ECC_CURVE_TABLE; u8Loop++)
   {
      if (ecc_curve_oid[u8Loop].cktype == sKeyType)
      {
         printf("-> %s\n", ecc_curve_oid[u8Loop].sCurveName);
      }
   }
}

/*
    FUNCTION:        void P11Util_DisplayEncryptionParam()
*/
void P11Util_DisplayEncryptionParam(CK_ULONG    bKeyFlag)
{
   CK_BYTE u8Loop;

   printf("Supported public exponant value : \n");
   // loop on all structure
   for (u8Loop = 0; u8Loop < SIZE_ENCRYPTION_ALGO_TABLE; u8Loop++)
   {
      if (encryption_algo[u8Loop].uFlag & bKeyFlag)
      {
         printf("-> %s\n", encryption_algo[u8Loop].sMechName);
      }
   }
}

/*
    FUNCTION:        P11_ENCRYPTION_MECH* P11Util_GetEncryptionParam(CK_CHAR_PTR sParamName)
*/
P11_ENCRYPTION_MECH* P11Util_GetEncryptionParam(CK_CHAR_PTR sParamName, CK_ULONG    bKeyFlag)
{
   CK_BYTE u8Loop;

   // loop on all curve structure
   for (u8Loop = 0; u8Loop < SIZE_ENCRYPTION_ALGO_TABLE; u8Loop++)
   {
      // if curve name match, return OID
      if (strcmp(encryption_algo[u8Loop].sMechName, sParamName) == 0)
      {
         // check the flag is matching
         if (encryption_algo[u8Loop].uFlag & bKeyFlag)
         {
            // return encryption algo param
            return (P11_ENCRYPTION_MECH*)&encryption_algo[u8Loop];
         }
      }
   };
   return NULL;
}

/*
    FUNCTION:        void P11Util_DisplayDerivationParam()
*/
void P11Util_DisplayDerivationParam()
{
   CK_BYTE u8Loop;

   printf("Supported public exponant value : \n");
   // loop on all structure
   for (u8Loop = 0; u8Loop < SIZE_DERIVATION_ALGO_TABLE; u8Loop++)
   {
      printf("-> %s\n", derivation_algo[u8Loop].sMechName);
   }
}

/*
    FUNCTION:        P11_DERIVE_MECH* P11Util_GetDerivationParam(CK_CHAR_PTR sParamName)
*/
P11_DERIVE_MECH* P11Util_GetDerivationParam(CK_CHAR_PTR sParamName)
{
   CK_BYTE u8Loop;

   // loop on all curve structure
   for (u8Loop = 0; u8Loop < SIZE_DERIVATION_ALGO_TABLE; u8Loop++)
   {
      // if curve name match, return OID
      if (strcmp(derivation_algo[u8Loop].sMechName, sParamName) == 0)
      {
         return (P11_DERIVE_MECH*)&derivation_algo[u8Loop];
      }
   };
   return NULL;
}


/*
    FUNCTION:        void P11Util_DisplayKdfType()
*/
void P11Util_DisplayKdfType()
{
   CK_BYTE u8Loop;

   printf("Supported Key Derivation Function type value : \n");
   // loop on all structure
   for (u8Loop = 0; u8Loop < SIZE_KDF_TYPE_TABLE; u8Loop++)
   {
      printf("-> %s\n", kdf_type[u8Loop].sKdfMechType);
   }
}

/*
    FUNCTION:        P11_DERIVE_MECH* P11Util_GetKdfType(CK_CHAR_PTR sParamName)
*/
CK_KDF_PRF_TYPE P11Util_GetKdfType(CK_CHAR_PTR sParamName)
{
   CK_BYTE u8Loop;

   // loop on all curve structure
   for (u8Loop = 0; u8Loop < SIZE_KDF_TYPE_TABLE; u8Loop++)
   {
      // if curve name match, return OID
      if (strcmp(kdf_type[u8Loop].sKdfMechType, sParamName) == 0)
      {
         return kdf_type[u8Loop].cKdfMechType;
      }
   };
   return 0;
}

/*
    FUNCTION:        void P11Util_DisplayKdfScheme()
*/
void P11Util_DisplayKdfScheme()
{
   CK_BYTE u8Loop;

   printf("Supported Key Derivation Function type value : \n");
   // loop on all structure
   for (u8Loop = 0; u8Loop < SIZE_KDF_SCHEME_TABLE; u8Loop++)
   {
      printf("-> %s\n", kdf_scheme[u8Loop].sKdfScheme);
   }
}

/*
    FUNCTION:        CK_KDF_PRF_ENCODING_SCHEME  P11Util_GetKdfScheme(CK_CHAR_PTR sParamName)
*/
CK_KDF_PRF_ENCODING_SCHEME  P11Util_GetKdfScheme(CK_CHAR_PTR sParamName)
{
   CK_BYTE u8Loop;

   // loop on all curve structure
   for (u8Loop = 0; u8Loop < SIZE_KDF_SCHEME_TABLE; u8Loop++)
   {
      // if curve name match, return OID
      if (strcmp(kdf_scheme[u8Loop].sKdfScheme, sParamName) == 0)
      {
         return kdf_scheme[u8Loop].cKdfScheme;
      }
   };
   return 0;
}


/*
    FUNCTION:        P11_EDDSA_OID_CONVERT* P11Util_EddsaConvertOidStd(CK_CHAR_PTR sOid, CK_LONG uOidLength)
*/
P11_EDDSA_OID_CONVERT* P11Util_EddsaConvertOidStd(CK_CHAR_PTR sOid, CK_LONG uOidLength)
{
   CK_BYTE u8Loop;

   // loop on all curve structure
   for (u8Loop = 0; u8Loop < SIZE_EDDSA_CONVERT_OID; u8Loop++)
   {
      // check if oid length match with request length
      if (eddsa_Convert_oid[u8Loop].uOidStdLength == uOidLength)
      {
         // compare oid value
         if (memcmp(eddsa_Convert_oid[u8Loop].sOidStd, sOid, uOidLength) == 0)
         {
            return (P11_EDDSA_OID_CONVERT*) & eddsa_Convert_oid[u8Loop];
         }
      }
   }
   return NULL;
}

/*
    FUNCTION:        P11_EDDSA_OID_CONVERT* P11Util_EddsaConvertOidStd(CK_CHAR_PTR sOid, CK_LONG uOidLength)
*/
P11_EDDSA_OID_CONVERT* P11Util_EddsaConvertOidToStd(CK_CHAR_PTR sOid, CK_LONG uOidLength)
{
   CK_BYTE u8Loop;

   // loop on all curve structure
   for (u8Loop = 0; u8Loop < SIZE_EDDSA_CONVERT_OID; u8Loop++)
   {
      // check if oid length match with request length
      if (eddsa_Convert_oid[u8Loop].uOidLengthHSM == uOidLength)
      {
         // compare oid value
         if (memcmp(eddsa_Convert_oid[u8Loop].sOidHSM, sOid, uOidLength) == 0)
         {
            return (P11_EDDSA_OID_CONVERT*)&eddsa_Convert_oid[u8Loop];
         }
      }
   }
   return NULL;
}

/*
    FUNCTION:        P11_HASH_MECH* P11Util_GetHash(CK_CHAR_PTR sHash)
*/
P11_HASH_MECH* P11Util_GetHash(CK_CHAR_PTR sHash, CK_ULONG uFlag)
{
   CK_BYTE u8Loop;

   // loop on all structure
   for (u8Loop = 0; u8Loop < SIZE_HASH_ALGO_TABLE; u8Loop++)
   {
      // if curve name match, return OID
      if (strcmp(hash_algo[u8Loop].sHashName, sHash) == 0)
      {
         if (hash_algo[u8Loop].uFlag & uFlag)
         {
            return (P11_HASH_MECH*)&hash_algo[u8Loop];
         }
      }
   };

   return NULL;
}

/*
    FUNCTION:        void P11Util_DisplaySupportedHash(CK_ULONG uFlag)
*/
void P11Util_DisplaySupportedHash(CK_ULONG uFlag)
{
   CK_BYTE u8Loop;

   printf("Supported hash value : \n");
   // loop on all structure
   for (u8Loop = 0; u8Loop < SIZE_HASH_ALGO_TABLE; u8Loop++)
   {
      if (hash_algo[u8Loop].uFlag & uFlag)
      {
         printf("-> %s\n", hash_algo[u8Loop].sHashName);
      }
   }
}

/*
    FUNCTION:        void P11Util_DisplaySupportedKCVMethod()
*/
void P11Util_DisplaySupportedKCVMethod()
{
   CK_BYTE u8Loop;

   printf("Supported KCV method : \n");
   // loop on all structure
   for (u8Loop = 0; u8Loop < SIZE_KCV_TYPE_TABLE; u8Loop++)
   {

      printf("-> %s\n", kcv_type[u8Loop].sKCVMechType);

   }
}

/*
    FUNCTION:        BYTE P11Util_GetKCVMethod(CK_CHAR_PTR sHash)
*/
BYTE P11Util_GetKCVMethod(CK_CHAR_PTR sKCV)
{
   CK_BYTE u8Loop;

   // loop on all structure
   for (u8Loop = 0; u8Loop < SIZE_KCV_TYPE_TABLE; u8Loop++)
   {
      // if curve name match, return OID
      if (strcmp(kcv_type[u8Loop].sKCVMechType, sKCV) == 0)
      {

         return kcv_type[u8Loop].cKCVMethod;

      }
   };

   return 0;
}

/*
    FUNCTION:        CK_ATTRIBUTE_TYPE P11Util_GetAttributeType(CK_CHAR_PTR sAttribute)
*/
CK_ATTRIBUTE_TYPE P11Util_GetAttributeType(CK_CHAR_PTR sAttribute)
{
   CK_BYTE u8Loop;
   // loop on all structure
   for (u8Loop = 0; u8Loop < SIZE_ATTR_TYPE_TABLE; u8Loop++)
   {
      // if curve name match, return OID
      if (strcmp(attr_type[u8Loop].sAttributeType, sAttribute) == 0)
      {

         return attr_type[u8Loop].cAttributeType;

      }
   };

   return -1;
}

/*
    FUNCTION:        void P11Util_DisplaySupportedAttribute()
*/
void P11Util_DisplaySupportedAttribute()
{
   CK_BYTE u8Loop;

   printf("Supported Attribute name : \n");
   // loop on all structure
   for (u8Loop = 0; u8Loop < SIZE_ATTR_TYPE_TABLE; u8Loop++)
   {

      printf("-> %s\n", attr_type[u8Loop].sAttributeType);

   }
}

/*
    FUNCTION:        P11_ML_DSA_KEY_SIZE P11Util_GetML_DSA_ParameterFromKeySize(CK_ULONG sPublicKeySize)
*/
P11_ML_DSA_KEY_SIZE * P11Util_GetML_DSA_ParameterFromKeySize(CK_ULONG sPublicKeySize)
{
   CK_BYTE u8Loop;
   // loop on all structure
   for (u8Loop = 0; u8Loop < SIZE_P11_ML_DSA_KEYSIZE_TABLE; u8Loop++)
   {
      // if curve name match, return OID
      if (ml_dsa_publickeysize[u8Loop].sPublicKeySize == sPublicKeySize)
      {

         return (P11_ML_DSA_KEY_SIZE*) &ml_dsa_publickeysize[u8Loop];

      }
   };

   return NULL;
}

/*
    FUNCTION:        P11_ML_DSA_KEY_SIZE* P11Util_GetML_DSA_ParameterFromParameterSet(CK_ML_DSA_PARAMETER_SET_TYPE sParameterSet)
*/
P11_ML_DSA_KEY_SIZE* P11Util_GetML_DSA_ParameterFromParameterSet(CK_ML_DSA_PARAMETER_SET_TYPE sParameterSet)
{
   CK_BYTE u8Loop;
   // loop on all structure
   for (u8Loop = 0; u8Loop < SIZE_P11_ML_DSA_KEYSIZE_TABLE; u8Loop++)
   {
      // if curve name match, return OID
      if (ml_dsa_publickeysize[u8Loop].sML_DSA_Parameter_Set == sParameterSet)
      {

         return (P11_ML_DSA_KEY_SIZE*)&ml_dsa_publickeysize[u8Loop];

      }
   };

   return NULL;
}